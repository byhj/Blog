<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Linux Dir]]></title>
      <url>https://byhj.github.io/blog/blog/2016/05/06/Linux-Dir/</url>
      <content type="html"><![CDATA[<p>/： 根目录，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中<br>/bin:/usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。<br>/boot： 放置linux系统启动时用到的一些文件。/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可<br>/dev： 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt。<br>/etc： 系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。注：/etc/X11存放与x windows有关的设置。<br>/home： 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</p>
<a id="more"></a>
<p>/lib:/usr/lib:/usr/local/lib： 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules。<br>/lost+fount： 系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于/disk 中，此目录下就会自动产生目录/disk/lost+found<br>/mnt:/media： 光盘默认挂载点，通常光盘挂载于/mnt/cdrom下，也不一定，可以选择任意位置进行挂载。<br>/opt： 给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 /usr/local 目录下<br>/proc： 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等<br>/root： 系统管理员root的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下。<br>/sbin:/usr/sbin:/usr/local/sbin： 放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。<br>/tmp： 一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下<br>/srv： 服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内<br>/usr： 应用程序存放目录，/usr/bin 存放应用程序， /usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local:存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间<br>/var： 放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message： 所有的登录文件存放目录，/var/spool/mail： 邮件存放的目录， /var/run: 程序或服务启动</p>
<p>后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>/dev： 目录<br>　　dev是设备(device)的英文缩写。/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和</p>
<p>windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。</p>
<p>　　Linux沿袭Unix的风格，将所有设备认成是一个文件。</p>
<p>　　设备文件分为两种：块设备文件(b)和字符设备文件(c)</p>
<p>　　设备文件一般存放在/dev目录下，对常见设备文件作如下说明：</p>
<p>　　/dev/hd[a-t]：IDE设备</p>
<p>　　/dev/sd[a-z]：SCSI设备</p>
<p>　　/dev/fd[0-7]：标准软驱</p>
<p>　　/dev/md[0-31]：软raid设备</p>
<p>　　/dev/loop[0-7]：本地回环设备</p>
<p>　　/dev/ram[0-15]：内存</p>
<p>　　/dev/null：无限数据接收设备,相当于黑洞</p>
<p>　　/dev/zero：无限零资源</p>
<p>　　/dev/tty[0-63]：虚拟终端</p>
<p>　　/dev/ttyS[0-3]：串口</p>
<p>　　/dev/lp[0-3]：并口</p>
<p>　　/dev/console：控制台</p>
<p>　　/dev/fb[0-31]：framebuffer</p>
<p>　　/dev/cdrom =&gt; /dev/hdc</p>
<p>　　/dev/modem =&gt; /dev/ttyS[0-9]</p>
<p>　　/dev/pilot =&gt; /dev/ttyS[0-9]</p>
<p>　　/dev/random：随机数设备</p>
<p>　　/dev/urandom：随机数设备</p>
<p>　　(PS：随机数设备，后面我会再写篇博客总结一下)</p>
<p>　　/dev目录下的节点是怎么创建的?</p>
<p>　　devf或者udev会自动帮你创建得。</p>
<p>　　kobject是sysfs文件系统的基础，udev通过监测、检测sysfs来获取新创建的设备的。</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>/etc： 目录<br>　　包含很多文件.许多网络配置文件也在/etc 中.<br>/etc/rc   or /etc/rc.d   or /etc/rc*.d  　　启动、或改变运行级时运行的scripts或scripts的目录.<br>/etc/passwd<br>　　用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息.<br>/etc/fstab<br>　　启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表. Linux下，也包括用swapon -a启用的swap区的信息.<br>/etc/group<br>　　类似/etc/passwd ，但说明的不是用户而是组.<br>/etc/inittab<br>　　init 的配置文件.<br>/etc/issue<br>　　getty 在登录提示符前的输出信息.通常包括系统的一段短说明或欢迎信息.内容由系统管理员确定.<br>/etc/motd<br>　　Message Of The Day，成功登录后自动输出.内容由系统管理员确定.经常用于通告信息，如计划关机时间的警告.<br>/etc/mtab<br>　　当前安装的文件系统列表.由scripts初始化，并由mount 命令自动更新.需要一个当前安装的文件系统的列表时使用，例如df 命令.<br>/etc/shadow<br>　　在安装了影子口令软件的系统上的影子口令文件.影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读.这使破译口令更困难.<br>/etc/login.defs<br>　　login 命令的配置文件.<br>/etc/printcap<br>　　类似/etc/termcap ，但针对打印机.语法不同.<br>/etc/profile , /etc/csh.login , /etc/csh.cshrc<br>　　登录或启动时Bourne或C shells执行的文件.这允许系统管理员为所有用户建立全局缺省环境.<br>/etc/securetty<br>　　确认安全终端，即哪个终端允许root登录.一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权.<br>/etc/shells<br>　　列出可信任的shell.chsh 命令允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录.<br>/etc/sysconfig<br>　　网络配置相关目录</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>/proc： 目录</p>
<p>档名    文件内容<br>/proc/cmdline     加载 kernel 时所下达的相关参数！查阅此文件，可了解系统是如何启动的！<br>/proc/cpuinfo     本机的 CPU 的相关资讯，包含时脉、类型与运算功能等<br>/proc/devices     这个文件记录了系统各个主要装置的主要装置代号，与 mknod 有关呢！<br>/proc/filesystems     目前系统已经加载的文件系统罗！<br>/proc/interrupts     目前系统上面的 IRQ 分配状态。<br>/proc/ioports     目前系统上面各个装置所配置的 I/O 位址。<br>/proc/kcore     这个就是内存的大小啦！好大对吧！但是不要读他啦！<br>/proc/loadavg     还记得 top 以及 uptime 吧？没错！上头的三个平均数值就是记录在此！<br>/proc/meminfo     使用 free 列出的内存资讯，嘿嘿！在这里也能够查阅到！<br>/proc/modules     目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序啦！<br>/proc/mounts     系统已经挂载的数据，就是用 mount 这个命令呼叫出来的数据啦！<br>/proc/swaps     到底系统挂加载的内存在哪里？呵呵！使用掉的 partition 就记录在此啦！<br>/proc/partitions     使用 fdisk -l 会出现目前所有的 partition 吧？在这个文件当中也有纪录喔！<br>/proc/pci     在 PCI 汇流排上面，每个装置的详细情况！可用 lspci 来查阅！<br>/proc/uptime     就是用 uptime 的时候，会出现的资讯啦！<br>/proc/version     核心的版本，就是用 uname -a 显示的内容啦！<br>/proc/bus/*     一些汇流排的装置，还有 U盘 的装置也记录在此喔！</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>/usr： 目录<br>　　/usr 文件系统经常很大，因为所有程序安装在这里. /usr 里的所有文件一般来自Linux distribution；本地安装的程序和其他东西在/usr/local 下.这样可能在升级新版系统或新distribution时无须重新安装全部程序.<br>/usr/etc            存放设置文件<br>/usr/games      存放游戏和教学文件<br>/usr/include      存放C开发工具的头文件<br>/usr/share         存放结构独立的数据<br>/usr/bin<br>　　几乎所有用户命令.有些命令在/bin 或/usr/local/bin 中.<br>/usr/sbin<br>　　根文件系统不必要的系统管理命令，例如多数服务程序.<br>/usr/share/man , /usr/share/info , /usr/share/doc<br>　　手册页、GNU信息文档和各种其他文档文件.<br>/usr/include<br>　　C编程语言的头文件.为了一致性这实际上应该在/usr/lib 下，但传统上支持这个名字.<br>/usr/lib<br>　　程序或子系统的不变的数据文件，包括一些site-wide配置文件.名字lib来源于库(library); 编程的原始库存在/usr/lib 里.<br>/usr/local<br>　　本地安装的软件和其他文件放在这里.<br>/usr/src             存放程序的源代码</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>/var： 目录<br>　　/var 包括系统一般运行时要改变的数据.每个系统是特定的，即不通过网络与其他计算机共享.<br>/var/catman<br>　　当要求格式化时的man页的cache.man页的源文件一般存在/usr/man/man<em> 中；有些man页可能有预格式化的版本，存在/usr/man/cat</em> 中.而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了. (/var/catman 经常被清除，就象清除临时目录一样.)<br>/var/lib<br>　　系统正常运行时要改变的文件.<br>/var/local<br>　　/usr/local 中安装的程序的可变数据(即系统管理员安装的程序).注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock .<br>/var/lock<br>　　锁定文件.许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件.其他程序注意到这个锁定文件，将不试图使用这个设备或文件.<br>/var/log<br>　　各种程序的Log文件，特别是login  (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除.<br>/var/run<br>　　保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息.<br>/var/spool<br>　　mail, news, 打印队列和其他队列工作的目录.每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中.<br>/var/tmp<br>　　比/tmp 允许的大或需要存在较长时间的临时文件. (虽然系统管理员可能不允许/var/tmp 有很旧的文件.)</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p> 比较重要的目录</p>
<pre><code>在 Linux 系统中，有几个目录是特别需要注意的，以下提供几个需要注意的目录，以及预设相关的用途：　
    /etc： 这个目录相当重要，如前所述，你的开机与系统数据文件均在这个目录之下，因此当这个目录被破坏，那你的系统大概也就差不多该死掉了！而在往后的文件中，你会发现我们常常使用这个目录下的 /etc/rc.d/init.d 这个子目录，因为这个 init.d 子目录是开启一些 Linux 系统服务的 scripts （可以想成是批次檔 ）的地方。而在 /etc/rc.d/rc.local 这个文件是开机的执行档。　
    /bin, /sbin, /usr/bin, /usr/sbin： 这是系统预设的执行文件的放置目录，例如 root 常常使用的 userconf, netconf, perl, gcc, c++ 等等的数据都放在这几个目录中，所以如果你在提示字符下找不到某个执行档时，可以在这四个目录中查一查！其中， /bin, /usr/bin 是给系统使用者使用的指令，而 /sbin, /usr/sbin 则是给系统管理员使用的指令！  　
    /usr/local： 这是系统预设的让你安装你后来升级的套件的目录。例如，当你发现有更新的 Web 套件（如 Apache ）可以安装，而你又不想以 rpm 的方式升级你的套件，则你可以将 apache 这个套件安装在 /usr/local 底下。安装在这里有个好处，因为目前大家的系统都是差不多的，所以如果你的系统要让别人接管的话，也比较容易上手呀！也比较容易找的到数据喔！因此，如果你有需要的话，通常我都会将 /usr/local/bin 这个路径加到我的 path 中。　
    /home： 这个是系统将有账号的人口的家目录设置的地方。    　
    /var： 这个路径就重要了！不论是登入、各类服务的问题发生时的记录、以及常态性的服务记录等等的记录目录，所以当你的系统有问题时，就需要来这个目录记录的文件数据中察看问题的所在啰！而 mail 的预设放置也是在这里，所以他是很重要的    　
    /usr/share/man, /usr/local/man： 这两个目录为放置各类套件说明档的地方，例如你如果执行 man man，则系统会自动去找这两个目录下的所有说明文件
</code></pre><p>文件种类：</p>
<p>谈完了文件格式之后，再来谈谈所谓的文件种类吧！我们在刚刚的属性介绍中提到了最前面的标志 ( d 或 - ) 可以代表目录或文件，那就是不同的文件种类啦！Linux 的文件种类主要有底下</p>
<p>这几种：<br>    正规文件( regular file )：就是一般类型的文件，在由 ls –al 所显示出来的属性方面，第一个属性为 [ - ]。另外，依照文件的内容，又大略可以分为两种文件种类：<br>        纯文字文件(ascii) ：这是 Unix 系统中最多的一种啰，几乎只要我们可以用来做为设定的文件都属于这一种；<br>        二进制文件(binary) ：通常执行档除了 scripts （文字型批次文件）之外，就是这一种文件格式；<br>    目录 (directory)：就是目录！第一个属性为 [ d ]；<br>    连结档 (link)：就是类似 Windows 底下的快捷方式啦！第一个属性为 [ l ]；<br>    设备档 (device)：与系统周边相关的一些文件，通常都集中在 /dev 这个目录之下！通常又分为两种：<br>    区块 (block) 设备档 ：就是一些储存数据，以提供系统存取的接口设备，简单的说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的文件啦！第一个属性为 [ b ]；<br>    字符 (character) 设备档 ：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为 [ c ]。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GLSL内置变量]]></title>
      <url>https://byhj.github.io/blog/blog/2016/05/02/GLSL(Built-in%20Variable)/</url>
      <content type="html"><![CDATA[<p>　  GLSL定义了许多内置变量，这些变量一般被用于固定管线的运算，这里主要介绍下各个变量的内容与用法。</p>
<h1 id="Vertex-shader-inputs"><a href="#Vertex-shader-inputs" class="headerlink" title="Vertex shader inputs"></a>Vertex shader inputs</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_VertexID</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_InstanceID</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="gl-VertexID​"><a href="#gl-VertexID​" class="headerlink" title="gl_VertexID​"></a>gl_VertexID​</h2><p>因为Vertex Shader对每个Vertex执行一次，所以gl_VertexID是Vertex Shader当前处理的顶点的索引。</p>
<p>gl_InstanceID​<br>在执行Instance绘制时，gl_InstanceID是当前实例的索引值，当没有进行Instance绘制时它是默认的0值。</p>
<h1 id="Vertex-shader-outputs"><a href="#Vertex-shader-outputs" class="headerlink" title="Vertex shader outputs"></a>Vertex shader outputs</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> gl_PerVertex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">vec4</span>  <span class="built_in">gl_Position</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="gl-PerVertex​"><a href="#gl-PerVertex​" class="headerlink" title="gl_PerVertex​"></a>gl_PerVertex​</h2><p>Vertex Shader的输出结构，在开启光栅化时会被传输。</p>
<h2 id="gl-Position"><a href="#gl-Position" class="headerlink" title="gl_Position"></a>gl_Position</h2><p>一般是在Vertex Shader经过Model View Proj矩阵变换过的Vertex数据，此时数据位于clip-space， 数据是齐次坐标[x, y, z, w].</p>
<h2 id="gl-PointSize​"><a href="#gl-PointSize​" class="headerlink" title="gl_PointSize​"></a>gl_PointSize​</h2><p>绘制像素点大小，在绘制point primitives时有效。</p>
<h2 id="gl-ClipDistance​"><a href="#gl-ClipDistance​" class="headerlink" title="gl_ClipDistance​"></a>gl_ClipDistance​</h2><h2 id="同于用户自定义的裁剪计算，非负值说明顶点在裁剪面内，负值则被裁剪。"><a href="#同于用户自定义的裁剪计算，非负值说明顶点在裁剪面内，负值则被裁剪。" class="headerlink" title="同于用户自定义的裁剪计算，非负值说明顶点在裁剪面内，负值则被裁剪。"></a>同于用户自定义的裁剪计算，非负值说明顶点在裁剪面内，负值则被裁剪。</h2><h1 id="Tessellation-Control-Shaders-input"><a href="#Tessellation-Control-Shaders-input" class="headerlink" title="Tessellation Control Shaders input:"></a>Tessellation Control Shaders input:</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_PatchVerticesIn</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_PrimitiveID</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_InvocationID</span>;</span><br></pre></td></tr></table></figure>
<h2 id="gl-PatchVerticesIn​"><a href="#gl-PatchVerticesIn​" class="headerlink" title="gl_PatchVerticesIn​"></a>gl_PatchVerticesIn​</h2><p>每个patch多少个vertices</p>
<h2 id="gl-PrimitiveID​"><a href="#gl-PrimitiveID​" class="headerlink" title="gl_PrimitiveID​"></a>gl_PrimitiveID​</h2><p>当前patch索引值</p>
<h2 id="gl-InvocationID​"><a href="#gl-InvocationID​" class="headerlink" title="gl_InvocationID​"></a>gl_InvocationID​</h2><p>当前patch中vertices的索引值。</p>
<p>Tessellation control shader接受vertex shader的输出作为输入，需要注意的是，由于shader对每个patch执行一次，所以该结构是数组模式。</p>
 <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> gl_PerVertex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">vec4</span> <span class="built_in">gl_Position</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125; <span class="built_in">gl_in</span>[<span class="built_in">gl_MaxPatchVertices</span>];</span><br></pre></td></tr></table></figure>
<p>结构内的变量含义在vertex shader那里已经说过了，gl_MaxPatchVertices是patch的顶点数，注意跟gl_PatchVerticesIn的区别。</p>
<h1 id="Tessellation-Control-Shaders-output"><a href="#Tessellation-Control-Shaders-output" class="headerlink" title="Tessellation Control Shaders output:"></a>Tessellation Control Shaders output:</h1> <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">patch</span> <span class="keyword">out</span> <span class="type">float</span> <span class="built_in">gl_TessLevelOuter</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">patch</span> <span class="keyword">out</span> <span class="type">float</span> <span class="built_in">gl_TessLevelInner</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p> 这个两个分量主要分别设置了patch的内外细分度</p>
<p>Tessellation Control Shader需要将vertex shader传入的数据继续传输下去，所以有类似的输出的结构体：</p>
 <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> gl_PerVertex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">vec4</span> <span class="built_in">gl_Position</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125; <span class="built_in">gl_out</span>[];</span><br></pre></td></tr></table></figure>
<h1 id="Tessellation-evaluation-shader-inputs"><a href="#Tessellation-evaluation-shader-inputs" class="headerlink" title="Tessellation evaluation shader inputs"></a>Tessellation evaluation shader inputs</h1> <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> <span class="built_in">gl_TessCoord</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_PatchVerticesIn</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_PrimitiveID</span>;</span><br></pre></td></tr></table></figure>
<p>gl_TessCoord​<br>细分坐标，利用插值可以产生新的细分顶点</p>
<p>gl_PatchVerticesIn​<br>与control中类似</p>
<p>gl_PrimitiveID​<br>当前patch的索引值</p>
<p>patch in float gl_TessLevelOuter[4];<br>patch in float gl_TessLevelInner[2];</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> gl_PerVertex</span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">vec4</span> <span class="built_in">gl_Position</span>;</span><br><span class="line"> <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line"> <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125; <span class="built_in">gl_in</span>[<span class="built_in">gl_MaxPatchVertices</span>];</span><br></pre></td></tr></table></figure>
<h1 id="Tessellation-evaluation-shader-outputs"><a href="#Tessellation-evaluation-shader-outputs" class="headerlink" title="Tessellation evaluation shader outputs"></a>Tessellation evaluation shader outputs</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> gl_PerVertex &#123;</span><br><span class="line">  <span class="type">vec4</span> <span class="built_in">gl_Position</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>gl_Position​<br>产生细分数据的clip-space坐标值</p>
<p>gl_PointSize​<br>像素点大小</p>
<p>gl_ClipDistance​<br>自定义裁剪变量，前面已说明</p>
<hr>
<h1 id="Geometry-shader-inputs"><a href="#Geometry-shader-inputs" class="headerlink" title="Geometry shader inputs"></a>Geometry shader inputs</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> gl_PerVertex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">vec4</span> <span class="built_in">gl_Position</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125; <span class="built_in">gl_in</span>[];</span><br></pre></td></tr></table></figure>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_PrimitiveIDIn</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_InvocationID</span>;  <span class="comment">//Requires GLSL 4.0 or ARB_gpu_shader5</span></span><br></pre></td></tr></table></figure>
<p>gl_PrimitiveIDIn​</p>
<p>gl_InvocationID​</p>
<h1 id="Geometry-shader-outputs"><a href="#Geometry-shader-outputs" class="headerlink" title="Geometry shader outputs"></a>Geometry shader outputs</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> gl_PerVertex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">vec4</span> <span class="built_in">gl_Position</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">  <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>out int gl_PrimitiveID;<br>gl_PrimitiveID = gl_PrimitiveIDIn;</p>
<p>层次渲染通过下面的变量实现：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">int</span> <span class="built_in">gl_Layer</span>;</span><br><span class="line"><span class="keyword">out</span> <span class="type">int</span> <span class="built_in">gl_ViewportIndex</span>; <span class="comment">//Requires GL 4.1 or ARB_viewport_array.</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Fragment-Shaders-input"><a href="#Fragment-Shaders-input" class="headerlink" title="Fragment Shaders input."></a>Fragment Shaders input.</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> <span class="built_in">gl_FragCoord</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">bool</span> <span class="built_in">gl_FrontFacing</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> <span class="built_in">gl_PointCoord</span>;</span><br></pre></td></tr></table></figure>
<h2 id="gl-FragCoord​"><a href="#gl-FragCoord​" class="headerlink" title="gl_FragCoord​"></a>gl_FragCoord​</h2><p>fragment在window space的位置量， [x,y,z]其中z值会被写入到gl_FragDepth中，而w值等于 1 /w(clip), w(clip)是插值后的gl_Position<br>的w值。gl_FragCoord的原点可以通过下面命令改变，默认原点在bottom-left：<br>layout(origin_upper_left) in vec4 gl_FragCoord;</p>
<h2 id="gl-FrontFacing​"><a href="#gl-FrontFacing​" class="headerlink" title="gl_FrontFacing​"></a>gl_FrontFacing​</h2><p>用于判断是否处于正面，如果是back-face，结果为负。</p>
<h2 id="gl-PointCoord​"><a href="#gl-PointCoord​" class="headerlink" title="gl_PointCoord​"></a>gl_PointCoord​</h2><p>Point primitive在的位置，范围[0, 1]，原点在upper-left,可以用来实现Spirtes，可以通过下面命令修改原点位置：<br>glPointParameteri(GL_POINT_SPRITE_COORD_ORIGIN, GL_LOWER_LEFT);​</p>
<p>OpenGL 4.0增加了几个系统产生的输入变量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_SampleID</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> <span class="built_in">gl_SamplePosition</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_SampleMaskIn</span>[];</span><br></pre></td></tr></table></figure>
<h2 id="gl-SampleID​"><a href="#gl-SampleID​" class="headerlink" title="gl_SampleID​"></a>gl_SampleID​</h2><p>整数值代表当前fragment的sample标志。</p>
<p>##gl_SamplePosition​<br>当前sample在fragment的位置，[0, 1]。</p>
<h2 id="gl-SampleMaskIn​"><a href="#gl-SampleMaskIn​" class="headerlink" title="gl_SampleMaskIn​"></a>gl_SampleMaskIn​</h2><p>用于多重采样</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_PrimitiveID</span>;</span><br></pre></td></tr></table></figure>
<h2 id="gl-ClipDistance​-1"><a href="#gl-ClipDistance​-1" class="headerlink" title="gl_ClipDistance​"></a>gl_ClipDistance​</h2><p>经过插值过的裁剪变量。</p>
<h2 id="gl-PrimitiveID​-1"><a href="#gl-PrimitiveID​-1" class="headerlink" title="gl_PrimitiveID​"></a>gl_PrimitiveID​</h2><p>当前图元索引值</p>
<p>OpenGL 4.3增加了下面两个内置输入变量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_Layer</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">int</span> <span class="built_in">gl_ViewportIndex</span>;</span><br></pre></td></tr></table></figure>
<h2 id="gl-Layer​"><a href="#gl-Layer​" class="headerlink" title="gl_Layer​"></a>gl_Layer​</h2><p>当前layer索引值</p>
<h2 id="gl-ViewportIndex​"><a href="#gl-ViewportIndex​" class="headerlink" title="gl_ViewportIndex​"></a>gl_ViewportIndex​</h2><p>当前viewport索引值</p>
<h1 id="Fragment-shader-outputs"><a href="#Fragment-shader-outputs" class="headerlink" title="Fragment shader outputs"></a>Fragment shader outputs</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">float</span> <span class="built_in">gl_FragDepth</span>;</span><br><span class="line"><span class="keyword">out</span> <span class="keyword">in</span> <span class="built_in">gl_SampleMask</span>[];</span><br></pre></td></tr></table></figure>
<h2 id="gl-FragDepth​"><a href="#gl-FragDepth​" class="headerlink" title="gl_FragDepth​"></a>gl_FragDepth​</h2><p>一般为gl_FragCoord;</p>
<hr>
<h1 id="Compute-Shaders-input"><a href="#Compute-Shaders-input" class="headerlink" title="Compute Shaders input."></a>Compute Shaders input.</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">uvec3</span> <span class="built_in">gl_NumWorkGroups</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">uvec3</span> <span class="built_in">gl_WorkGroupID</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">uvec3</span> <span class="built_in">gl_LocalInvocationID</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">uvec3</span> <span class="built_in">gl_GlobalInvocationID</span>;</span><br><span class="line"><span class="keyword">in</span> <span class="type">uint</span>  <span class="built_in">gl_LocalInvocationIndex</span>;</span><br></pre></td></tr></table></figure>
<h2 id="gl-NumWorkGroups​"><a href="#gl-NumWorkGroups​" class="headerlink" title="gl_NumWorkGroups​"></a>gl_NumWorkGroups​</h2><p>工作组总的数量</p>
<h2 id="gl-WorkGroupID​"><a href="#gl-WorkGroupID​" class="headerlink" title="gl_WorkGroupID​"></a>gl_WorkGroupID​</h2><p>当前工作组索引值</p>
<h2 id="gl-LocalInvocationID​"><a href="#gl-LocalInvocationID​" class="headerlink" title="gl_LocalInvocationID​"></a>gl_LocalInvocationID​</h2><p>工作组内本地工作组的索引值，XYZ处于[0,gl_NumWorkGroups.XYZ]。</p>
<h2 id="gl-GlobalInvocationID​"><a href="#gl-GlobalInvocationID​" class="headerlink" title="gl_GlobalInvocationID​"></a>gl_GlobalInvocationID​</h2><p>全局的实例索引值，等于下面的值：<br>gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;</p>
<h2 id="gl-LocalInvocationIndex​"><a href="#gl-LocalInvocationIndex​" class="headerlink" title="gl_LocalInvocationIndex​"></a>gl_LocalInvocationIndex​</h2><p>本地工作组内索引值：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_LocalInvocationIndex</span> =</span><br><span class="line">        <span class="built_in">gl_LocalInvocationID</span>.z * <span class="built_in">gl_WorkGroupSize</span>.x * <span class="built_in">gl_WorkGroupSize</span>.y +</span><br><span class="line">        <span class="built_in">gl_LocalInvocationID</span>.y * <span class="built_in">gl_WorkGroupSize</span>.x +</span><br><span class="line">        <span class="built_in">gl_LocalInvocationID</span>.x;</span><br></pre></td></tr></table></figure></p>
<h1 id="Compute-shader-other-variables"><a href="#Compute-shader-other-variables" class="headerlink" title="Compute shader other variables"></a>Compute shader other variables</h1><p>const uvec3 gl_WorkGroupSize;   // GLSL ≥ 4.30</p>
<h1 id="Shaders-uniforms"><a href="#Shaders-uniforms" class="headerlink" title="Shaders  uniforms"></a>Shaders  uniforms</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct gl_DepthRangeParameters</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> near;</span><br><span class="line">    <span class="type">float</span> far;</span><br><span class="line">    <span class="type">float</span> diff;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> gl_DepthRangeParameters <span class="built_in">gl_DepthRange</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> <span class="built_in">gl_NumSamples</span>; <span class="comment">//GLSL 4.20</span></span><br></pre></td></tr></table></figure>
<p>详细介绍<a href="https://www.opengl.org/wiki/Built-in_Variable_(GLSL" target="_blank" rel="external">GLSL Build-In Variable</a>#Fragment_shader_outputs)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vulkan]]></title>
      <url>https://byhj.github.io/blog/blog/2016/04/13/Vulkan-Introduction/</url>
      <content type="html"><![CDATA[<h1 id="Devices-and-Queues"><a href="#Devices-and-Queues" class="headerlink" title="Devices and Queues"></a>Devices and Queues</h1><a id="more"></a>
<hr>
<h1 id="Command-Buffers"><a href="#Command-Buffers" class="headerlink" title="Command Buffers"></a>Command Buffers</h1><hr>
<h1 id="Synchronmization"><a href="#Synchronmization" class="headerlink" title="Synchronmization"></a>Synchronmization</h1><hr>
<h1 id="Render-pass"><a href="#Render-pass" class="headerlink" title="Render pass"></a>Render pass</h1><hr>
<h1 id="Shaders"><a href="#Shaders" class="headerlink" title="Shaders"></a>Shaders</h1><hr>
<h1 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h1><hr>
<h1 id="Memory-allocation"><a href="#Memory-allocation" class="headerlink" title="Memory allocation"></a>Memory allocation</h1><hr>
<h1 id="Resource-Creation"><a href="#Resource-Creation" class="headerlink" title="Resource Creation"></a>Resource Creation</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[QT-static]]></title>
      <url>https://byhj.github.io/blog/blog/2016/01/22/QT-static/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>安装python, perl, ruby.<br>打开对应版本的开发人员命令提示， cd到Qt目录执行环境设置。</p>
<a id="more"></a>
<p>设置：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QMAKE_<span class="built_in">CFLAGS_RELEASE</span>    = -O2 -MD -Zc:strictStrings</span><br><span class="line"></span><br><span class="line">QMAKE_<span class="built_in">CFLAGS_RELEASE_WITH_DEBUGINFO</span> += -O2 -MD -Zi -Zc:strictStrings</span><br><span class="line"></span><br><span class="line">QMAKE_<span class="built_in">CFLAGS_DEBUG</span>      = -Zi -MDd</span><br><span class="line"></span><br><span class="line"><span class="comment">//将以上改为</span></span><br><span class="line"></span><br><span class="line">QMAKE_<span class="built_in">CFLAGS_RELEASE</span>    = -O2 -MT -Zc:strictStrings</span><br><span class="line"></span><br><span class="line">QMAKE_<span class="built_in">CFLAGS_RELEASE_WITH_DEBUGINFO</span> += -O2 -MT -Zi -Zc:strictStrings</span><br><span class="line"></span><br><span class="line">QMAKE_<span class="built_in">CFLAGS_DEBUG</span>      = -Zi -MTd</span><br></pre></td></tr></table></figure></p>
<p>参数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure -confirm-license -opensource -mp -platform win32-msvc2013 -debug-and-<span class="keyword">release</span> -<span class="keyword">static</span> -prefix <span class="string">" C:\Qt\5.5.0-static-vs2013"</span> -qt-<span class="keyword">sql</span>-sqlite -qt-<span class="keyword">sql</span>-odbc -<span class="keyword">plugin</span>-<span class="keyword">sql</span>-sqlite -<span class="keyword">plugin</span>-<span class="keyword">sql</span>-odbc -qt-zlib -qt-libpng -qt-libjpeg -opengl desktop -qt-freetype -<span class="keyword">no</span>-qml-debug -<span class="keyword">no</span>-angle -nomake tests -nomake examples -<span class="keyword">skip</span> qtwebkit</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmake</span><br><span class="line">nmake <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-Math]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/25/OpenGL-Math/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>　　主要介绍怎么使用glm开源项目作为OpenGL程序的Math库.</p>
<a id="more"></a>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"common/shader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GLuint Width(<span class="number">1200</span>), Height(<span class="number">800</span>);     <span class="comment">//window size</span></span><br><span class="line"><span class="keyword">void</span> key_callback(GLFWwindow *window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode);</span><br><span class="line"><span class="keyword">void</span> init();</span><br><span class="line"><span class="keyword">void</span> render();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"Starting GLFW context, OpenGL3.3"</span> &lt;&lt; std::endl;</span><br><span class="line">	glfwInit();</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//opengl 3.3</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); <span class="comment">//using opengl core file</span></span><br><span class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a GLFWwindow object that we can use for GLFW's functions</span></span><br><span class="line">	GLFWwindow *window = glfwCreateWindow(Width, Height, <span class="string">"OpenGL Tutorial"</span>, nullptr, nullptr);</span><br><span class="line">	glfwSetWindowPos(window, <span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line">	<span class="built_in">if</span> (window == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; std::endl;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		<span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glfwSetKeyCallback(window, key_callback);  <span class="comment">//keyboard function</span></span><br><span class="line">	glewExperimental = GL_TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize GLEW to setup the OpenGL Function pointers</span></span><br><span class="line">	<span class="built_in">if</span> (glewInit() != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">"Failed to initializz GLEW"</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">	<span class="built_in">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">		render();</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	<span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shader TriangleShader(<span class="string">"Triangle Shader"</span>);</span><br><span class="line">GLuint vao, vbo;</span><br><span class="line">GLuint program;</span><br><span class="line">GLuint mvp_loc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLfloat VertexData[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">-1.0</span>f, <span class="number">-1.0</span>f, <span class="number">0.0</span>f,</span><br><span class="line">	 <span class="number">1.0</span>f, <span class="number">-1.0</span>f, <span class="number">0.0</span>f,</span><br><span class="line">	 <span class="number">0.0</span>f,  <span class="number">1.0</span>f, <span class="number">0.0</span>f</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> init_buffer()</span><br><span class="line">&#123;</span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;vbo);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(VertexData), VertexData, GL_STATIC_DRAW);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> init_shader()</span><br><span class="line">&#123;</span><br><span class="line">	TriangleShader.init();</span><br><span class="line">	TriangleShader.<span class="built_in">attach</span>(GL_VERTEX_SHADER, <span class="string">"triangle.vert"</span>);</span><br><span class="line">	TriangleShader.<span class="built_in">attach</span>(GL_FRAGMENT_SHADER, <span class="string">"triangle.frag"</span>);</span><br><span class="line">	TriangleShader.link();</span><br><span class="line">	program = TriangleShader.GetProgram();</span><br><span class="line"></span><br><span class="line">	mvp_loc = glGetUniformLocation(program, <span class="string">"mvp"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> init_vertexArray()</span><br><span class="line">&#123;</span><br><span class="line">	glGenVertexArrays(<span class="number">1</span>, &amp;vao);</span><br><span class="line">	glBindVertexArray(vao);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> init()</span><br><span class="line">&#123;</span><br><span class="line">	init_shader();</span><br><span class="line">	init_buffer();</span><br><span class="line">	init_vertexArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> render()</span><br><span class="line">&#123;</span><br><span class="line">	glClearColor(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">0.4</span>f, <span class="number">0.0</span>f);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	glUseProgram(program);</span><br><span class="line">	<span class="keyword">float</span> time = glfwGetTime();</span><br><span class="line"></span><br><span class="line">	glm::mat4 model = rotate(glm::mat4(<span class="number">1.0</span>f), time, glm::vec3(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f));</span><br><span class="line">	glm::mat4 view = glm::lookAt(glm::vec3(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">3.0</span>f), glm::vec3(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f),</span><br><span class="line">		                         glm::vec3(<span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f) );</span><br><span class="line">	glm::mat4 proj = glm::perspective(<span class="number">45.0</span>f, <span class="keyword">float</span>(Width) / Height, <span class="number">0.1</span>f, <span class="number">1000.0</span>f);</span><br><span class="line">	glm::mat4 mvp = proj * view * model;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//When you send the data to shader, we should glUseProgram() first;</span></span><br><span class="line"></span><br><span class="line">	glUniformMatrix4fv(mvp_loc, <span class="number">1</span>, GL_FALSE, &amp;mvp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	glBindVertexArray(vao);</span><br><span class="line">	glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">	glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">	glUseProgram(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> key_callback(GLFWwindow *window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">if</span> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">		glfwSetWindowShouldClose(window, GL_TRUE);  <span class="comment">//we should close the window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>triangle.vert<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> mvp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">gl_Position</span> = mvp * <span class="type">vec4</span>(Position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>triangle.frag<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-Debug]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/25/OpenGL-Debug/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[在GLFW3中使用AntTweakBar]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/25/GLFW3-AntTweakBar/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>　　本文主要介绍怎么在GLFW3中使用AntTweakBar吗，旧版本的GLFW使用在AntTweakBar的Example中<br>已经有了，所以在这里不作介绍。注意，程序是在OpenGL-Framework里面介绍的代码为基础的，如果有不了解的<br>地方，请先阅读那一篇教程.</p>
<a id="more"></a>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>App.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __APP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __APP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;AntTweakBar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_ANT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ScreenWidth = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;( GetSystemMetrics(SM_CXSCREEN) * <span class="number">0.75</span> );</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ScreenHeight = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(  GetSystemMetrics(SM_CYSCREEN) * <span class="number">0.75</span> );</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PosX = (GetSystemMetrics(SM_CXSCREEN) - ScreenWidth) ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PosY = (GetSystemMetrics(SM_CYSCREEN) - ScreenHeight);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ScreenWidth = <span class="number">1200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ScreenHeight = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PosX = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PosY = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> byhj</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ogl</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> App</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		App() &#123;&#125;</span><br><span class="line">		<span class="keyword">virtual</span> ~App() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;App&gt; the_app)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Override</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_InitInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Init</span><span class="params">()</span>	  </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Update</span><span class="params">()</span>   </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Render</span><span class="params">()</span>	  </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Shutdown</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_KeyCallback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Movement</span><span class="params">(GLFWwindow *window)</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_MouseCallback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_ScrollCallback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">struct</span> WindowInfo</span><br><span class="line">		&#123;</span><br><span class="line">			WindowInfo() :title(<span class="string">"OpenGL BlueBook : "</span>),</span><br><span class="line">				Width(ScreenWidth),</span><br><span class="line">				Height(ScreenHeight),</span><br><span class="line">				posX(PosX),</span><br><span class="line">				posY(PosY) &#123;&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">			<span class="keyword">int</span> Width;</span><br><span class="line">			<span class="keyword">int</span> Height;</span><br><span class="line">			<span class="keyword">int</span> posX, posY;</span><br><span class="line">		&#125;windowInfo;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">GetAspect</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">GetScreenWidth</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">GetScreenHeight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetGLRenderer</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			return m_GLRenderer;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetGLVersion</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			return m_GLVersion;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetGLSLVersion</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			return m_GLSLVersion;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">static</span>  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;App&gt; app;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glfw_key</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glfw_mouse</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glfw_scroll</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glfw_mouseButton</span><span class="params">(GLFWwindow *window, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glfw_char</span><span class="params">(GLFWwindow *window, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> m_GLRenderer;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> m_GLVersion;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> m_GLSLVersion;</span><br><span class="line"></span><br><span class="line">	&#125;;  <span class="comment">//class</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">//namespace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//namespace</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//</span></span></span><br></pre></td></tr></table></figure>
<p>App.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"App.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> byhj</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> ogl</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> App::v_KeyCallback(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</span><br><span class="line">	<span class="keyword">if</span> (key == GLFW_KEY_C &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">		glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;App&gt; App::app;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> App::glfw_key(GLFWwindow * window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_ANT</span></span><br><span class="line">	TwEventKeyGLFW(key, action);</span><br><span class="line"></span><br><span class="line">	app-&gt;v_KeyCallback(window, key, scancode, action, mode);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> App::glfw_mouse(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_ANT</span></span><br><span class="line">	TwEventMousePosGLFW(xpos, ypos);</span><br><span class="line"></span><br><span class="line">	app-&gt;v_MouseCallback(window, xpos, ypos);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> App::glfw_scroll(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_ANT</span></span><br><span class="line">	TwEventMouseWheelGLFW(xoffset);</span><br><span class="line"></span><br><span class="line">	app-&gt;v_ScrollCallback(window, xoffset, yoffset);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">void</span> App::glfw_mouseButton(GLFWwindow *window, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span><br><span class="line">&#123;</span><br><span class="line">	TwEventMouseButtonGLFW(x, y);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">void</span> App::glfw_char(GLFWwindow *window, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	TwEventCharGLFW(x, GLFW_PRESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> App::Run(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;App&gt; the_app)</span><br><span class="line">&#123;</span><br><span class="line">	app = the_app;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting GLFW context"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (!glfwInit())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to initialize GLFW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v_InitInfo();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Add this to use the debug output</span></span><br><span class="line">	glfwWindowHint( GLFW_OPENGL_DEBUG_CONTEXT, <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GLFWwindow *window = glfwCreateWindow(windowInfo.Width, windowInfo.Height,</span><br><span class="line">		                                  windowInfo.title.c_str(), nullptr, nullptr);</span><br><span class="line">	glfwSetWindowPos(window, windowInfo.posX, windowInfo.posY);</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	glfwSetCursorPosCallback(window, glfw_mouse);          <span class="comment">// - Directly redirect GLFW mouse position events to AntTweakBar</span></span><br><span class="line">	glfwSetScrollCallback(window, glfw_scroll);    <span class="comment">// - Directly redirect GLFW mouse wheel events to AntTweakBar</span></span><br><span class="line">	glfwSetKeyCallback(window, glfw_key);                         <span class="comment">// - Directly redirect GLFW key events to AntTweakBar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_ANT</span></span><br><span class="line">	glfwSetMouseButtonCallback(window, glfw_mouseButton); <span class="comment">// - Directly redirect GLFW mouse button events to AntTweakBar</span></span><br><span class="line">	glfwSetCharCallback(window, glfw_char);                      <span class="comment">// - Directly redirect GLFW char events to AntTweakBar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);</span></span><br><span class="line">	<span class="comment">// GLFW Options</span></span><br><span class="line">	glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	glewExperimental = GL_TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Check the GLSL and OpenGL status</span></span><br><span class="line">	<span class="keyword">if</span> (glewInit() != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> GLubyte *renderer = glGetString( GL_RENDERER );  </span><br><span class="line">	<span class="keyword">const</span> GLubyte *vendor = glGetString( GL_VENDOR );  </span><br><span class="line">	<span class="keyword">const</span> GLubyte *version = glGetString( GL_VERSION );  </span><br><span class="line">	<span class="keyword">const</span> GLubyte *glslVersion = glGetString( GL_SHADING_LANGUAGE_VERSION );  </span><br><span class="line"></span><br><span class="line">	m_GLRenderer = (const char *)renderer;</span><br><span class="line">	m_GLVersion  = (const char *)version;</span><br><span class="line">	m_GLSLVersion = (const char *)glslVersion;</span><br><span class="line"></span><br><span class="line">	GLint major, minor;  </span><br><span class="line">	glGetIntegerv(GL_MAJOR_VERSION, &amp;major);  </span><br><span class="line">	glGetIntegerv(GL_MINOR_VERSION, &amp;minor);  </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GL Vendor    :"</span> &lt;&lt; vendor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GL Renderer  : "</span> &lt;&lt; renderer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GL Version (std::string)  : "</span> &lt;&lt; version &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GL Version (integer) : "</span> &lt;&lt; major &lt;&lt; <span class="string">"."</span> &lt;&lt; minor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GLSL Version : "</span> &lt;&lt; glslVersion &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------------------------------------------------------------"</span></span><br><span class="line">		      &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, major); <span class="comment">//opengl 4.3</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, minor);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a GLFWwindow object that we can use for GLFW's functions</span></span><br><span class="line">	v_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sw, sh;</span><br><span class="line">		glfwGetWindowSize(window, &amp;sw, &amp;sh);</span><br><span class="line"></span><br><span class="line">		glViewport(<span class="number">0</span>, <span class="number">0</span>, sw, sh);</span><br><span class="line"></span><br><span class="line">		glfwPollEvents();</span><br><span class="line">		v_Movement(window);</span><br><span class="line"></span><br><span class="line">		v_Update();</span><br><span class="line">		<span class="comment">//Render for the object</span></span><br><span class="line">		v_Render();</span><br><span class="line"></span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line">	&#125;</span><br><span class="line">	v_Shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> App::GetAspect()</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(ScreenWidth) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(ScreenHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> App::GetScreenWidth()</span><br><span class="line">&#123;</span><br><span class="line">	return ScreenWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> App::GetScreenHeight()</span><br><span class="line">&#123;</span><br><span class="line">	return ScreenHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用AntTweakBar</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-GLUT]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/25/OpenGL-GLUT/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>　　在以前很多项目使用GLUT库创建OpenGL环境，由于GLUT项目已经放弃开发和维护，在这里建议大家使用新的freeglut库。<br>可以在<a href="http://freeglut.sourceforge.net/" target="_blank" rel="external">freeglut</a>网站下载最新的版本。</p>
<a id="more"></a>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>　　在官网上下载对应版本的freeglut，你可以下载源码自己编译或者下载已经编译好的库文件。freeglut的使用<br>基本跟glut的使用一样。在做好前期准备工作后，使用VS创建一个空项目，将freeglut库文件目录添加到项目的库依赖目录。<br>下面介绍怎么使用freeglut创建一个OpenGL环境的窗口：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;GL/freeglut.h&gt;</span><br><span class="line"></span><br><span class="line">//初始化，运行一次</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">	glClearColor(<span class="number">0</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">0</span>f, <span class="number">1</span>.<span class="number">0</span>f)<span class="comment">;</span></span><br><span class="line">	glClearDepth(<span class="number">1</span>.<span class="number">0</span>f)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//渲染代码，循环运行</span><br><span class="line">void render()</span><br><span class="line">&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	glColor3f(<span class="number">1</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">0</span>f)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	glBegin(GL_TRIANGLES)<span class="comment">;</span></span><br><span class="line">	  glVertex3f(-<span class="number">1</span>.<span class="number">0</span>f, -<span class="number">1</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">0</span>f)<span class="comment">;</span></span><br><span class="line">	  glVertex3f(<span class="number">1</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">0</span>f)<span class="comment">;</span></span><br><span class="line">	  glVertex3f(<span class="number">0</span>.<span class="number">0</span>, <span class="number">1</span>.<span class="number">0</span>, <span class="number">0</span>.<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">	glEnd()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	glutSwapBuffers()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reshape(int w, int h)</span><br><span class="line">&#123;</span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	glutInit(&amp;argc, argv)<span class="comment">;</span></span><br><span class="line">	glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH)<span class="comment">;</span></span><br><span class="line">	glutInitWindowPosition(<span class="number">300</span>, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">	glutInitWindowSize(<span class="number">720</span>, <span class="number">640</span>)<span class="comment">;</span></span><br><span class="line">	glutCreateWindow("Hello World")<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	init()<span class="comment">;</span></span><br><span class="line">	glutDisplayFunc(render)<span class="comment">;</span></span><br><span class="line">	glutReshapeFunc(reshape)<span class="comment">;</span></span><br><span class="line">	glutIdleFunc(render)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	glutMainLoop()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-GLFW]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/25/OpenGL-GLFW/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>　　GLFW是一个创建OpenGL环境窗口的开源跨平台程序库，它同时可以处理输入和事件。<br>目前来说，它比OpenGL以前使用的GLUT框架更加成熟和方便。更多信息在<a href="http://www.glfw.org/" target="_blank" rel="external">GLFW</a><br>的官网有介绍。本文主要简单介绍GLFW的使用。</p>
<a id="more"></a>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p>　　在官网上下载对应版本的GLFW，你可以下载源码自己编译或者下载已经编译好的库文件。由于最新的GLFW3跟以前的<br>GLFW版本有所区别，所以从旧版本升级的程序需要按照官网提供的教程进行修改.<br>在做好前期准备工作后，使用VS创建一个空项目，将glfw库文件目录添加到项目的库依赖目录。<br>下面介绍怎么使用GLFW创建一个OpenGL环境的窗口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化GLFW环境</span></span><br><span class="line">	<span class="keyword">if</span> (!glfwInit())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error: can not init the glfw!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		return <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个窗口化的OpenGL环境窗口</span></span><br><span class="line">	GLFWwindow *pWindow = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, NULL, NULL);</span><br><span class="line">	<span class="keyword">if</span> (!pWindow)</span><br><span class="line">	&#123;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		return <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用创建的OpenGL环境窗口</span></span><br><span class="line">	glfwMakeContextCurrent(pWindow);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环直到用户关闭窗口</span></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(pWindow))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在这里添加渲染代码</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//交换双缓存</span></span><br><span class="line">		glfwSwapBuffers(pWindow);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//处理事件</span></span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//结束，销毁初始化创建的资源</span></span><br><span class="line">	glfwTerminate();</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Effective STL 总结]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/24/EffectiveSTL/</url>
      <content type="html"><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>　  　对于C++而言，容器是比数组功能更强大更灵活的工具，它可以动态增长或缩减，可以自己管理内存，可以自己记住包含了多少对象，它们还限定了自己所支持的操作的复杂性。对于不同情况我们需要选择不同<br>的容器。</p>
<p><a id="more"></a>　</p>
<h2 id="慎重选择容器类型"><a href="#慎重选择容器类型" class="headerlink" title="慎重选择容器类型"></a>慎重选择容器类型</h2><p>　　C++主要提供了一下几种类型的容器</p>
<ul>
<li>标准STL序列容器：vector, string, deque, list</li>
<li>标准STL管理容器：set,  multiset, map, multimap</li>
<li>非标准序列容器 ：slist, rope</li>
<li>非标准关联容器 ：hash_set, hash_multiset, hash_map, hash_multimap</li>
<li>几种标准的非STL容器：bitset, valarray, stack, queue, priority_queue</li>
</ul>
<p>　　在不同情况下我们需要采用不同的容器，一般情况下我们都使用vector容器。我们主要把容器以两种方法进行<br>分类：</p>
<ul>
<li>对连续内存容器：把它的元素存放在一块或多块(动态分配)内存中，每块内存中存有多个元素。</li>
<li>基于节点的容器：容器中元素的插入或删除只影响到指向节点的指针，而不影响节点本身的内容。</li>
</ul>
<p>下面分别介绍在不同情况下怎么选择合适的容器：</p>
<p>1.在容器的任意位置插入新元素：选择序列容器。<br>2.是否关系容器中元素是排序的：不关心使用散列容器，关心则避免。<br>3.必须是标准C++一部分：不是可以考虑slist, rope。<br>4.需要哪种类型迭代器:<br>5.当发生元素的插入或删除时，避免移动原来容器元素是否很重要<br>6.容器中元素的布局是否需要和C兼容：<br>7：元素的查找速度是否是关键的考虑因素：<br>8：容器内部使用了引用计数技术：<br>9：对插入和删除操作，需要事物语义:<br>10:需要时迭代器，指针和引用变为无效的次数最少：<br>11：序列容器迭代器是随机访问类型，只有没有删除操作发生，且插入操作发生在容器末尾，则指向数据的指针和引用就不会变为无效：deque</p>
<h2 id="不要试图编写独立于容器类型的代码"><a href="#不要试图编写独立于容器类型的代码" class="headerlink" title="不要试图编写独立于容器类型的代码"></a>不要试图编写独立于容器类型的代码</h2><h2 id="确保容器中的对象副本正确而高效"><a href="#确保容器中的对象副本正确而高效" class="headerlink" title="确保容器中的对象副本正确而高效"></a>确保容器中的对象副本正确而高效</h2><h2 id="调用empty而不是检测size-是否为0"><a href="#调用empty而不是检测size-是否为0" class="headerlink" title="调用empty而不是检测size()是否为0"></a>调用empty而不是检测size()是否为0</h2><h2 id="区间成员函数优先于与之对应的单元素成员函数"><a href="#区间成员函数优先于与之对应的单元素成员函数" class="headerlink" title="区间成员函数优先于与之对应的单元素成员函数"></a>区间成员函数优先于与之对应的单元素成员函数</h2><h2 id="当心C-编译器最烦人的分析机制"><a href="#当心C-编译器最烦人的分析机制" class="headerlink" title="当心C++编译器最烦人的分析机制"></a>当心C++编译器最烦人的分析机制</h2><h2 id="如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉"><a href="#如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉" class="headerlink" title="如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉"></a>如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉</h2><h2 id="切勿创建包含auto-ptr的容器对象"><a href="#切勿创建包含auto-ptr的容器对象" class="headerlink" title="切勿创建包含auto_ptr的容器对象"></a>切勿创建包含auto_ptr的容器对象</h2><h2 id="了解分配子的约定和限制"><a href="#了解分配子的约定和限制" class="headerlink" title="了解分配子的约定和限制"></a>了解分配子的约定和限制</h2><h2 id="理解自定义分配子的合理用法"><a href="#理解自定义分配子的合理用法" class="headerlink" title="理解自定义分配子的合理用法"></a>理解自定义分配子的合理用法</h2><h2 id="切勿对STL容器的线程安全性有不切实际的依赖"><a href="#切勿对STL容器的线程安全性有不切实际的依赖" class="headerlink" title="切勿对STL容器的线程安全性有不切实际的依赖"></a>切勿对STL容器的线程安全性有不切实际的依赖</h2><hr>
<h1 id="vector和string"><a href="#vector和string" class="headerlink" title="vector和string"></a>vector和string</h1><h2 id="vector和string优先于动态分配的数组"><a href="#vector和string优先于动态分配的数组" class="headerlink" title="vector和string优先于动态分配的数组"></a>vector和string优先于动态分配的数组</h2><h2 id="使用reserve来避免不必要的重新分配"><a href="#使用reserve来避免不必要的重新分配" class="headerlink" title="使用reserve来避免不必要的重新分配"></a>使用reserve来避免不必要的重新分配</h2><h2 id="注意string实现的多样性"><a href="#注意string实现的多样性" class="headerlink" title="注意string实现的多样性"></a>注意string实现的多样性</h2><h2 id="了解如何把vector和string数据传给旧的API"><a href="#了解如何把vector和string数据传给旧的API" class="headerlink" title="了解如何把vector和string数据传给旧的API"></a>了解如何把vector和string数据传给旧的API</h2><h2 id="使用“swap技巧”除去多余的容量"><a href="#使用“swap技巧”除去多余的容量" class="headerlink" title="使用“swap技巧”除去多余的容量"></a>使用“swap技巧”除去多余的容量</h2><h2 id="避免试图vector"><a href="#避免试图vector" class="headerlink" title="避免试图vector"></a>避免试图vector<bool></bool></h2><hr>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><h2 id="理解相等和等价的区别"><a href="#理解相等和等价的区别" class="headerlink" title="理解相等和等价的区别"></a>理解相等和等价的区别</h2><h2 id="为包含指针的关联容器指定比较类型"><a href="#为包含指针的关联容器指定比较类型" class="headerlink" title="为包含指针的关联容器指定比较类型"></a>为包含指针的关联容器指定比较类型</h2><h2 id="总是让比较函数在等值情况下返回false"><a href="#总是让比较函数在等值情况下返回false" class="headerlink" title="总是让比较函数在等值情况下返回false"></a>总是让比较函数在等值情况下返回false</h2><h2 id="切勿直接修改set或multiset中的键"><a href="#切勿直接修改set或multiset中的键" class="headerlink" title="切勿直接修改set或multiset中的键"></a>切勿直接修改set或multiset中的键</h2><h2 id="考虑用排序的vector替代关联容器"><a href="#考虑用排序的vector替代关联容器" class="headerlink" title="考虑用排序的vector替代关联容器"></a>考虑用排序的vector替代关联容器</h2><h2 id="当笑料至关重要时，请在map-operator-与map-insert之间谨慎做出选择"><a href="#当笑料至关重要时，请在map-operator-与map-insert之间谨慎做出选择" class="headerlink" title="当笑料至关重要时，请在map::operator[]与map::insert之间谨慎做出选择"></a>当笑料至关重要时，请在map::operator[]与map::insert之间谨慎做出选择</h2><h2 id="熟悉非标准的散列容器"><a href="#熟悉非标准的散列容器" class="headerlink" title="熟悉非标准的散列容器"></a>熟悉非标准的散列容器</h2><hr>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="iterator优先于const-iterator-reverse-iterator-const-reverse-iterator"><a href="#iterator优先于const-iterator-reverse-iterator-const-reverse-iterator" class="headerlink" title="iterator优先于const_iterator, reverse_iterator, const_reverse_iterator"></a>iterator优先于const_iterator, reverse_iterator, const_reverse_iterator</h2><h2 id="使用distance和advnace将容器的const-iteator转换成iterator"><a href="#使用distance和advnace将容器的const-iteator转换成iterator" class="headerlink" title="使用distance和advnace将容器的const_iteator转换成iterator"></a>使用distance和advnace将容器的const_iteator转换成iterator</h2><h2 id="正确理解由reverse-iterator的base-成员函数所产生的iterator的用法"><a href="#正确理解由reverse-iterator的base-成员函数所产生的iterator的用法" class="headerlink" title="正确理解由reverse_iterator的base()成员函数所产生的iterator的用法"></a>正确理解由reverse_iterator的base()成员函数所产生的iterator的用法</h2><h2 id="对于逐个字符的输入请考虑使用istreambuf-iterator"><a href="#对于逐个字符的输入请考虑使用istreambuf-iterator" class="headerlink" title="对于逐个字符的输入请考虑使用istreambuf_iterator"></a>对于逐个字符的输入请考虑使用istreambuf_iterator</h2><hr>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="确保目标区间足够大"><a href="#确保目标区间足够大" class="headerlink" title="确保目标区间足够大"></a>确保目标区间足够大</h2><h2 id="了解各种和排序有关的选择"><a href="#了解各种和排序有关的选择" class="headerlink" title="了解各种和排序有关的选择"></a>了解各种和排序有关的选择</h2><h2 id="如果确实需要删除元素，则需要在remove这一类算法之后调用erase"><a href="#如果确实需要删除元素，则需要在remove这一类算法之后调用erase" class="headerlink" title="如果确实需要删除元素，则需要在remove这一类算法之后调用erase"></a>如果确实需要删除元素，则需要在remove这一类算法之后调用erase</h2><h2 id="对包含指针的容器使用remove这一类算法时要特别小心"><a href="#对包含指针的容器使用remove这一类算法时要特别小心" class="headerlink" title="对包含指针的容器使用remove这一类算法时要特别小心"></a>对包含指针的容器使用remove这一类算法时要特别小心</h2><h2 id="了解哪些算法要求使用排序的区间作为参数"><a href="#了解哪些算法要求使用排序的区间作为参数" class="headerlink" title="了解哪些算法要求使用排序的区间作为参数"></a>了解哪些算法要求使用排序的区间作为参数</h2><h2 id="通过mismatch或lexicographical-compare实现简单的忽略大小写的字符串比较"><a href="#通过mismatch或lexicographical-compare实现简单的忽略大小写的字符串比较" class="headerlink" title="通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较"></a>通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较</h2><h2 id="理解copy-if算法的正确实现"><a href="#理解copy-if算法的正确实现" class="headerlink" title="理解copy_if算法的正确实现"></a>理解copy_if算法的正确实现</h2><h2 id="使用accumulate或者for-each进行区间统计"><a href="#使用accumulate或者for-each进行区间统计" class="headerlink" title="使用accumulate或者for_each进行区间统计"></a>使用accumulate或者for_each进行区间统计</h2><hr>
<h1 id="函数子，函数子类，函数及其他"><a href="#函数子，函数子类，函数及其他" class="headerlink" title="函数子，函数子类，函数及其他"></a>函数子，函数子类，函数及其他</h1><h2 id="遵循按值传递的原则来设计函数子类"><a href="#遵循按值传递的原则来设计函数子类" class="headerlink" title="遵循按值传递的原则来设计函数子类"></a>遵循按值传递的原则来设计函数子类</h2><h2 id="确保判别式是”纯函数”"><a href="#确保判别式是”纯函数”" class="headerlink" title="确保判别式是”纯函数”"></a>确保判别式是”纯函数”</h2><h2 id="若一个类是函数子，则应使它可配接"><a href="#若一个类是函数子，则应使它可配接" class="headerlink" title="若一个类是函数子，则应使它可配接"></a>若一个类是函数子，则应使它可配接</h2><h2 id="理解ptr-fun-mem-fun和mem-fun-ref的来由"><a href="#理解ptr-fun-mem-fun和mem-fun-ref的来由" class="headerlink" title="理解ptr_fun, mem_fun和mem_fun_ref的来由"></a>理解ptr_fun, mem_fun和mem_fun_ref的来由</h2><h2 id="确保less与operator-lt-具有相同的语义"><a href="#确保less与operator-lt-具有相同的语义" class="headerlink" title="确保less与operator&lt;具有相同的语义"></a>确保less<t>与operator&lt;具有相同的语义</t></h2><hr>
<h1 id="在程序中使用STL"><a href="#在程序中使用STL" class="headerlink" title="在程序中使用STL"></a>在程序中使用STL</h1><h2 id="算法调用优先于手写的循环"><a href="#算法调用优先于手写的循环" class="headerlink" title="算法调用优先于手写的循环"></a>算法调用优先于手写的循环</h2><h2 id="容器的成员函数优先于同名的算法"><a href="#容器的成员函数优先于同名的算法" class="headerlink" title="容器的成员函数优先于同名的算法"></a>容器的成员函数优先于同名的算法</h2><h2 id="正确区分const-find-binary-search-lower-bound-upper-bound和equal-range"><a href="#正确区分const-find-binary-search-lower-bound-upper-bound和equal-range" class="headerlink" title="正确区分const, find, binary_search, lower_bound, upper_bound和equal_range"></a>正确区分const, find, binary_search, lower_bound, upper_bound和equal_range</h2><h2 id="考虑使用函数对象而不是函数作为STL算法的参数"><a href="#考虑使用函数对象而不是函数作为STL算法的参数" class="headerlink" title="考虑使用函数对象而不是函数作为STL算法的参数"></a>考虑使用函数对象而不是函数作为STL算法的参数</h2><h2 id="考虑产生”直写型”的代码"><a href="#考虑产生”直写型”的代码" class="headerlink" title="考虑产生”直写型”的代码"></a>考虑产生”直写型”的代码</h2><h2 id="总是包含正确的头文件"><a href="#总是包含正确的头文件" class="headerlink" title="总是包含正确的头文件"></a>总是包含正确的头文件</h2><h2 id="学会分享与STL相关的编译器诊断信息"><a href="#学会分享与STL相关的编译器诊断信息" class="headerlink" title="学会分享与STL相关的编译器诊断信息"></a>学会分享与STL相关的编译器诊断信息</h2><h2 id="熟悉与STL相关的Web站点"><a href="#熟悉与STL相关的Web站点" class="headerlink" title="熟悉与STL相关的Web站点"></a>熟悉与STL相关的Web站点</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Direct3D-Math]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/20/Direct3D-Math/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>　　本文主要介绍Direct3D开发中使用的数学运算库。</p>
<a id="more"></a>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h2 id="D3DXMath"><a href="#D3DXMath" class="headerlink" title="D3DXMath"></a>D3DXMath</h2><p>　　这是Direct3D旧版本的数学运算库，主要有d3dx9math, d3dx10math.</p>
<h2 id="xnamath"><a href="#xnamath" class="headerlink" title="xnamath"></a>xnamath</h2><p>　　在DirectX11的SDK中包含了一个新的数学库xnamath，它主要是为XNA平台开发编写的，采用了<br>SIMD提供运算效率，在PC程序开发中也可以使用。</p>
<h2 id="DirectXMath"><a href="#DirectXMath" class="headerlink" title="DirectXMath"></a>DirectXMath</h2><p>　　在Windows8.x之后DirectX SDK不再以单一组件形式提供，D3DXMath也已经被抛弃，微软推荐采用新使用C++编写的DirectXMath数学库，<br>它可以看做xnamath的升级版本。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _m128 XMVECTOR</span><br></pre></td></tr></table></figure></p>
<p>为了能充分利用SIMD的效率，在使用时可以采用以下步骤进行操作：</p>
<ul>
<li>局部或全局变使用XMVECTOR， XMMATRIX</li>
<li>类的数据成员使用XMFLOAT<em>， XMFLOAT</em>x*</li>
<li>在进行运算前，使用相应的loading函数将XMFLOAT<em> / XMFLOAT</em>x*转换为XMVECTOR/ XMMATRIX</li>
<li>使用XMVECTOR / XMMATRIX进行运算</li>
<li>采用相应的storage函数将结果从XMVECTOR/XMMATRIX转换回XMFLOAT<em> / XMFLOAT</em>x*</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> XMMATRIX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fix-up for (1st) XMMATRIX parameter to pass in-register for ARM64 and vector call; by reference otherwise</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ( defined(_M_ARM64) || _XM_VECTORCALL_ ) &amp;&amp; !defined(_XM_NO_INTRINSICS_)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> XMMATRIX FXMMATRIX;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> XMMATRIX&amp; FXMMATRIX;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fix-up for (2nd+) XMMATRIX parameters to pass by reference</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> XMMATRIX&amp; CXMMATRIX;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _XM_NO_INTRINSICS_</span></span><br><span class="line"><span class="keyword">struct</span> XMMATRIX</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">__declspec(align(<span class="number">16</span>)) <span class="keyword">struct</span> XMMATRIX</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _XM_NO_INTRINSICS_</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        XMVECTOR r[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> _11, _12, _13, _14;</span><br><span class="line">            <span class="keyword">float</span> _21, _22, _23, _24;</span><br><span class="line">            <span class="keyword">float</span> _31, _32, _33, _34;</span><br><span class="line">            <span class="keyword">float</span> _41, _42, _43, _44;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">float</span> m[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    XMVECTOR r[<span class="number">4</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XMVECTOR XMLoadFloat4(<span class="name">COSNT</span> XMFLOAT4 *pSource);</span><br><span class="line">VOID     XMStoreFloat4(XMFLOAT4 *pDestination, FXMVECTOR V)<span class="comment">;</span></span><br><span class="line">FLOAT XMVectorGetX(<span class="name">FXMVECTOR</span> V)<span class="comment">;</span></span><br><span class="line">XMVECTOR XMVectorSetX(<span class="name">FXMVECTOR</span> V, FLOAT x)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> XM_PI           = <span class="number">3.141592654</span>f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">float</span> XMConvertToRadians(<span class="keyword">float</span> fDegrees) &#123; <span class="built_in">return</span> fDegrees * (XM_PI / <span class="number">180.0</span>f); &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">float</span> XMConvertToDegrees(<span class="keyword">float</span> fRadians) &#123; <span class="built_in">return</span> fRadians * (<span class="number">180.0</span>f / XM_PI); &#125;</span><br></pre></td></tr></table></figure>
<p>可以参考MSDN博客上的这篇文章<a href="http://blogs.msdn.com/b/chuckw/archive/2012/03/27/introducing-directxmath.aspx" target="_blank" rel="external">Introducing DirectXMath</a><br>#</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGLES-Android]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/20/OpenGLES-Android/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Design Pattern]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/20/DesignPattern/</url>
      <content type="html"><![CDATA[<h1 id="Creational"><a href="#Creational" class="headerlink" title="Creational"></a>Creational</h1><p>创建型模式与对象的创建有关<br><a id="more"></a></p>
<p>Class</p>
<h2 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化推迟到其子类。<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span></span><br><span class="line"><span class="meta">## Abstract Factory</span></span><br><span class="line">提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Builder</span></span><br><span class="line">将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以产生不同的表示。</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Singleton</span></span><br><span class="line">保证一个类仅有一个实例，并提供一个访问它的全局访问点。</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Prototype</span></span><br><span class="line">用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Structural</span></span><br><span class="line">处理类或对象的组合。</span><br><span class="line"></span><br><span class="line">Class</span><br><span class="line"><span class="comment">## Adapter</span></span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Object</span></span><br><span class="line"><span class="meta">## Adapter</span></span><br><span class="line">将一个类的接口转换成客户端希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</span><br></pre></td></tr></table></figure>
<p>class Target<br>{<br>public:<br>   virtual ~Target() = default;<br>   virtual std::string Operation() = 0;<br>};</p>
<p>class Adaptee<br>{<br>public:<br>   virtual  ~Adaptee() = default;<br>   std::string method()<br>   {<br>     return “Adapter”;<br>   }<br>};</p>
<p>class Adapter: public Target, private Adaptee<br>{<br>public:<br>    string Opration() override<br>    {<br>      return method();<br>    }<br>};<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Bridge</span></span><br><span class="line">将抽象部分与它的实现部分分离，使它们都可以独立地变化。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Composite</span></span><br><span class="line">将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Decorator</span></span><br><span class="line">动态地给一个对象添加一些额外的职责。</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Facade</span></span><br><span class="line">为子系统中的一组接口提供一个一致的界面，定义了一个高层接口，使得子系统更加容易使用。</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Flyweight</span></span><br><span class="line">运用共享技术有效地支持大量细粒度的对象。</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## Proxy</span></span><br><span class="line">为其他对象提供一种代理以控制对这个对象的访问。</span><br></pre></td></tr></table></figure>
<p>```</p>
<hr>
<h1 id="Behavioral"><a href="#Behavioral" class="headerlink" title="Behavioral"></a>Behavioral</h1><p>对类或对象怎么交互和怎样分配职责进行描述。</p>
<p>Class</p>
<h2 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h2><p>　　定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可<br>重定义该算法的某些特定步骤。</p>
<p>Object</p>
<h2 id="Chain-Of-Responsibility"><a href="#Chain-Of-Responsibility" class="headerlink" title="Chain Of Responsibility"></a>Chain Of Responsibility</h2><p>　　使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，<br>并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><p>　　将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</p>
<h2 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h2><p>　　给定一个句子，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>　　提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示。</p>
<h2 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h2><p>　　用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，<br>而且可以独立地改变它们之间的关系。</p>
<h2 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。</p>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都能得到通知并被自动更新。</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
<h2 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h2><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换，使得算法可独立于使用它的客户而变化。</p>
<h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2><p>表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<hr>
<p><a href="https://github.com/byhj/DesignPattern.git" target="_blank" rel="external">Source Code</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OGRE1.9-环境搭配]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/18/OGRE1.9-%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>  　　OGRE是一个面向对象的游戏(渲染)引擎，运用了很多常用的设计模式，它的场景管理尤为值得我们学习。<br>  官网上虽然提供了SDK开发包，但是如果要深入研究OGRE的架构，使用源码学习是一个更好的选择。<br>  本文主要介绍编译OGRE1.9源码的过程，其它版本的环境搭配也类似。</p>
  <a id="more"></a>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p>　　关于OGRE1.9 SDK的编译，只要下载官网上的安装包，安装对应版本的VS，下载安装Cmake。将OGRE1.9SDK安装目录下CMakeLists.txt文件使用Cmake打开，<br>选择你想要IDE(在这个选择你的对应VS版本)，点击Configure，然后Generate，编译生成的工程，就能得到Demo合集的程序。你也可以直接使用根目录下得sln<br>解决方案，用VS打开编译。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>下载<a href="https://bitbucket.org/sinbad/ogre/downloads" target="_blank" rel="external">OGRE1.9 Source</a><br>在OGRE的bitbucket有着它全部的开发信息，在这里你可以下载到那些正在开发版本。在这里我选择Tags下v1-9-0版本，点击右边的zip下载。<br>下载<a href="https://bitbucket.org/cabalistic/ogredeps/downloads" target="_blank" rel="external">Dependencies</a><br>同样的选择Tags那里进行下载。使用Cmake生成VS工程，编译生成Dependencies工程，将生成好的库文件目录放到Ogre1.9 Source的根目录下。使用Cmake生成OGRE1.9的VS工程，编译运行。</p>
<h1 id="Website"><a href="#Website" class="headerlink" title="Website"></a>Website</h1><ul>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Building+Ogre" target="_blank" rel="external">Building Ogre</a></li>
<li><a href="http://www.ogre3d.org/" target="_blank" rel="external">OGRE官网</a></li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php" target="_blank" rel="external">OGRE wiki</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Direct3D12-HelloWorld]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/18/Direct3D12-HelloWorld/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><a id="more"></a>
<h1 id="Create-A-Framework"><a href="#Create-A-Framework" class="headerlink" title="Create A Framework"></a>Create A Framework</h1><p>　　建立一个框架类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> D3DAPP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D3DAPP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windowsx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d2d1_3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dwrite.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d3d11on12.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d3d12.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dxgi1_4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;D3Dcompiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXMath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"d3dx12.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> byhj  </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> d3d</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> App</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	App() :m_AppName(<span class="string">L"DirectX12: "</span>), m_WndClassName(<span class="string">L"D3DWindow"</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~App() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InitApp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">LRESULT CALLBACK <span class="title">MessageHandler</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span>	<span class="keyword">void</span> <span class="title">v_Init</span><span class="params">()</span>     </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Update</span><span class="params">()</span>   </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Render</span><span class="params">()</span>   </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_Shutdown</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Convenience overrides for handling mouse input.</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_OnMouseDown</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span>&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_OnMouseUp</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>    </span>&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_OnMouseMove</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span>&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_OnMouseWheel</span><span class="params">(WPARAM btnState, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>   m_ScreenWidth;</span><br><span class="line">	<span class="keyword">int</span>   m_ScreenHeight;</span><br><span class="line">	<span class="keyword">float</span> m_ScreenFar;</span><br><span class="line">	<span class="keyword">float</span> m_ScreenNear;</span><br><span class="line">	<span class="keyword">int</span>   m_PosX;</span><br><span class="line">	<span class="keyword">int</span>   m_PosY;</span><br><span class="line"></span><br><span class="line">	LPCTSTR m_AppName;</span><br><span class="line">	LPCTSTR m_WndClassName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//void      GetVideoCardInfo(char &amp;, int &amp;);</span></span><br><span class="line">	<span class="function">HINSTANCE <span class="title">GetAppInst</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; return m_hInstance; &#125;</span><br><span class="line">	<span class="function">HWND      <span class="title">GetHwnd</span><span class="params">()</span>    <span class="keyword">const</span> </span>&#123; return m_hWnd; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">float</span>     <span class="title">GetAspect</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123; return <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_ScreenWidth)</span><br><span class="line">		                                  / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_ScreenHeight); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">init_window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HINSTANCE m_hInstance;</span><br><span class="line">	HWND      m_hWnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>框架类的实现</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"App.h"</span></span></span><br><span class="line"></span><br><span class="line">namespace byhj</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace d3d</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">static LRESULT CALLBACK WndProc(<span class="keyword">HWND</span>, UINT, <span class="keyword">WPARAM</span>, <span class="keyword">LPARAM</span>)<span class="comment">;</span></span><br><span class="line">static App *AppHandle = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主程序循环,首先创建一个windows窗口类，然后进入渲染循环，每次循环先处理消息，然后更新渲染资源然后显示新的图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> App::<span class="keyword">Run</span>()</span><br><span class="line">&#123;</span><br><span class="line">	InitApp()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	MSG msg<span class="comment">;</span></span><br><span class="line">	ZeroMemory(&amp;msg, sizeof(MSG))<span class="comment">;</span></span><br><span class="line">	<span class="keyword">while</span> (true)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (PeekMessage(&amp;msg, NULL, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE) )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(msg.message == WM_QUIT)</span><br><span class="line">				<span class="keyword">break</span><span class="comment">;</span></span><br><span class="line">			TranslateMessage(&amp;msg)<span class="comment">;</span></span><br><span class="line">			DispatchMessage(&amp;msg)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			v_Update()<span class="comment">;</span></span><br><span class="line">			v_Render()<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v_Shutdown()<span class="comment">;</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void App::InitApp()</span><br><span class="line">&#123;</span><br><span class="line">	init_window()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	v_Init()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool App::init_window()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Set the window in the middle of screen</span></span><br><span class="line">	m_ScreenWidth = GetSystemMetrics(SM_CXSCREEN) * <span class="number">0.75</span><span class="comment">;</span></span><br><span class="line">	m_ScreenHeight = GetSystemMetrics(SM_CYSCREEN) * <span class="number">0.75</span><span class="comment">;</span></span><br><span class="line">	m_PosX = (GetSystemMetrics(SM_CXSCREEN) - m_ScreenWidth)  / <span class="number">2</span><span class="comment">;</span></span><br><span class="line">	m_PosY = (GetSystemMetrics(SM_CYSCREEN) - m_ScreenHeight) / <span class="number">2</span><span class="comment">;</span></span><br><span class="line">	m_ScreenNear = <span class="number">0.1</span>f<span class="comment">;</span></span><br><span class="line">	m_ScreenFar  = <span class="number">1000.0</span>f<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	AppHandle = this<span class="comment">;</span></span><br><span class="line">	m_hInstance = GetModuleHandle(NULL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	WNDCLASSEX wc<span class="comment">;</span></span><br><span class="line">	wc.cbSize = sizeof(WNDCLASSEX)<span class="comment">;</span></span><br><span class="line">	wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC<span class="comment">;</span></span><br><span class="line">	wc.lpfnWndProc = WndProc<span class="comment">;</span></span><br><span class="line">	wc.cbClsExtra = NULL<span class="comment">;</span></span><br><span class="line">	wc.cbWndExtra = NULL<span class="comment">;</span></span><br><span class="line">	wc.hInstance = m_hInstance<span class="comment">;</span></span><br><span class="line">	wc.hIcon = LoadIcon(NULL, IDI_WINLOGO)<span class="comment">;</span></span><br><span class="line">	wc.hCursor = LoadCursor(NULL, IDC_ARROW)<span class="comment">;</span></span><br><span class="line">	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">	wc.lpszMenuName = NULL<span class="comment">;</span></span><br><span class="line">	wc.lpszClassName = m_WndClassName<span class="comment">;</span></span><br><span class="line">	wc.hIconSm = LoadIcon(NULL, IDI_WINLOGO)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!RegisterClassEx(&amp;wc))</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(NULL, L<span class="string">"Registering Class Failded"</span>,	L<span class="string">"Error"</span>, MB_OK | MB_ICONERROR)<span class="comment">;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Create the window and show</span></span><br><span class="line"></span><br><span class="line">	m_hWnd = CreateWindowEx(</span><br><span class="line">		NULL,	           </span><br><span class="line">		m_WndClassName,</span><br><span class="line">		m_AppName,</span><br><span class="line">		WS_OVERLAPPEDWINDOW,</span><br><span class="line">		m_PosX, m_PosY,</span><br><span class="line">		m_ScreenWidth,</span><br><span class="line">		m_ScreenHeight,</span><br><span class="line">		NULL,</span><br><span class="line">		NULL,</span><br><span class="line">		m_hInstance,</span><br><span class="line">		NULL</span><br><span class="line">		)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!m_hWnd )</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(NULL, L<span class="string">"Creating Window Failed"</span>, L<span class="string">"Error"</span>, MB_OK | MB_ICONERROR)<span class="comment">;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ShowWindow(m_hWnd, SW_SHOW)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> true<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理消息的回调函数</span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK App::MessageHandler(<span class="keyword">HWND</span> <span class="keyword">hWnd</span>, UINT uMsg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (uMsg)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">wParam</span> == VK_ESCAPE)</span><br><span class="line">				PostMessage(GetHwnd(), WM_DESTROY, <span class="number">0</span>, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	<span class="keyword">case</span> WM_MBUTTONDOWN:</span><br><span class="line">	<span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">		v_OnMouseDown(<span class="keyword">wParam</span>, GET_X_LPARAM(<span class="keyword">lParam</span>), GET_Y_LPARAM(<span class="keyword">lParam</span>))<span class="comment">;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">	<span class="keyword">case</span> WM_MBUTTONUP:</span><br><span class="line">	<span class="keyword">case</span> WM_RBUTTONUP:</span><br><span class="line">		v_OnMouseUp(<span class="keyword">wParam</span>, GET_X_LPARAM(<span class="keyword">lParam</span>), GET_Y_LPARAM(<span class="keyword">lParam</span>))<span class="comment">;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">		v_OnMouseMove(<span class="keyword">wParam</span>, GET_X_LPARAM(<span class="keyword">lParam</span>), GET_Y_LPARAM(<span class="keyword">lParam</span>))<span class="comment">;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">case</span> WM_MOUSEWHEEL:</span><br><span class="line">		v_OnMouseWheel(<span class="keyword">wParam</span>, GET_WHEEL_DELTA_WPARAM(<span class="keyword">wParam</span>), GET_Y_LPARAM(<span class="keyword">lParam</span>))<span class="comment">;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> DefWindowProc(<span class="keyword">hWnd</span>, uMsg, <span class="keyword">wParam</span>, <span class="keyword">lParam</span>)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK WndProc(<span class="keyword">HWND</span> <span class="keyword">hwnd</span>, UINT umessage, <span class="keyword">WPARAM</span> <span class="keyword">wparam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lparam</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(umessage)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		&#123;</span><br><span class="line">			PostQuitMessage(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		&#123;</span><br><span class="line">			PostQuitMessage(<span class="number">0</span>)<span class="comment">;		</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// All other messages pass to the message handler in the system class.</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> AppHandle-&gt;MessageHandler(<span class="keyword">hwnd</span>, umessage, <span class="keyword">wparam</span>, <span class="keyword">lparam</span>)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Create-a-Triangle"><a href="#Create-a-Triangle" class="headerlink" title="Create a Triangle"></a>Create a Triangle</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RENDERSYSTEM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RENDERSYSTEM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"d3d/App.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"triangle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d3d12.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wrl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXMath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dxgi1_4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Microsoft::WRL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> byhj</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RenderSysem : <span class="keyword">public</span> byhj::d3d::App</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">v_Init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">v_Update</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">v_Render</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">v_Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PopulateCommandList</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">WaitForPreviousFrame</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LoadAssets</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LoadPipeline</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> UINT FrameCount = <span class="number">2</span>;</span><br><span class="line">	D3D12_VIEWPORT m_Viewport;</span><br><span class="line">	D3D12_RECT m_ScissorRect;</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;IDXGISwapChain3&gt;           m_pSwapChain;</span><br><span class="line">	ComPtr&lt;ID3D12Device&gt;              m_pD3D12Device;</span><br><span class="line">	ComPtr&lt;ID3D12Fence&gt;               m_pD3D12Fence;</span><br><span class="line">	ComPtr&lt;ID3D12Resource&gt;            m_pRenderTargets[FrameCount];</span><br><span class="line">	ComPtr&lt;ID3D12CommandAllocator&gt;    m_pCommandAllocator;</span><br><span class="line">	ComPtr&lt;ID3D12CommandQueue&gt;        m_pCommandQueue;</span><br><span class="line">	ComPtr&lt;ID3D12DescriptorHeap&gt;      m_pRTVHeap;</span><br><span class="line">	ComPtr&lt;ID3D12GraphicsCommandList&gt; m_pCommandList;</span><br><span class="line"></span><br><span class="line">	UINT   m_RTVDescriptorSize;</span><br><span class="line">	UINT   m_FrameIndex;</span><br><span class="line">	HANDLE m_FenceEvent;</span><br><span class="line">	UINT64 m_FenceValue;</span><br><span class="line"></span><br><span class="line">	Triangle m_Triangle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>RenderSystem实现</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"RenderSystem.h"</span></span><br><span class="line"></span><br><span class="line">#include <span class="string">"d3d/Utility.h"</span></span><br><span class="line">#include <span class="string">"d3dx12.h"</span></span><br><span class="line">#include &lt;d3dcompiler.h&gt;</span><br><span class="line"></span><br><span class="line">namespace byhj</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void RenderSysem::v_Init()</span><br><span class="line">&#123;</span><br><span class="line">	m_Viewport.Width = static_cast&lt;float&gt;(m_ScreenWidth);</span><br><span class="line">	m_Viewport.Height = static_cast&lt;float&gt;(m_ScreenHeight);</span><br><span class="line">	m_Viewport.MaxDepth = <span class="number">1.0</span>f;</span><br><span class="line"></span><br><span class="line">	m_ScissorRect.right = static_cast&lt;LONG&gt;(m_ScreenWidth);</span><br><span class="line">	m_ScissorRect.bottom = static_cast&lt;LONG&gt;(m_ScreenHeight);</span><br><span class="line"></span><br><span class="line">	LoadPipeline();</span><br><span class="line">	LoadAssets();</span><br><span class="line">	m_Triangle.init_buffer(m_pD3D12Device);</span><br><span class="line">	m_Triangle.init_shader(m_pD3D12Device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RenderSysem::v_Update()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RenderSysem::v_Render()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Record all the commands we need to render the scene into the command list.</span></span><br><span class="line">	PopulateCommandList();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute the command list.</span></span><br><span class="line">	ID3D12CommandList *ppCommandLists[] =&#123; m_pCommandList.Get() &#125;;</span><br><span class="line">	<span class="function"><span class="title">m_pCommandQueue</span>-&gt;</span>ExecuteCommandLists(_countof(ppCommandLists), ppCommandLists);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Present the frame.</span></span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pSwapChain-&gt;</span>Present(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	WaitForPreviousFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RenderSysem::v_Shutdown()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	WaitForPreviousFrame();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ClouseHandle(m_FenceEvent);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RenderSysem::LoadPipeline()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">	<span class="comment">//Enable the D3D12 debug layer</span></span><br><span class="line">	ComPtr&lt;ID3D12Debug&gt; pDebugController;</span><br><span class="line">	<span class="keyword">if</span> (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&amp;pDebugController))))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">pDebugController</span>-&gt;</span>EnableDebugLayer();</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;IDXGIFactory4&gt; pFactory;</span><br><span class="line">	ThrowIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&amp;pFactory)));</span><br><span class="line"></span><br><span class="line">	bool UseWarpDevice = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UseWarpDevice)</span><br><span class="line">	&#123;</span><br><span class="line">		ComPtr&lt;IDXGIAdapter&gt; pWarpAdapter;</span><br><span class="line">		T<span class="function"><span class="title">hrowIfFailed</span>(pFactory-&gt;</span>EnumWarpAdapter(IID_PPV_ARGS(&amp;pWarpAdapter)));</span><br><span class="line">		ThrowIfFailed(D3D12CreateDevice(pWarpAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&amp;m_pD3D12Device)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ThrowIfFailed(D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&amp;m_pD3D12Device)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////	//Describe and Create the command queue//////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">	D3D12_COMMAND_QUEUE_DESC queueDesc =&#123;&#125;;</span><br><span class="line">	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;</span><br><span class="line">	queueDesc.Type  = D3D12_COMMAND_LIST_TYPE_DIRECT;</span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pD3D12Device-&gt;</span>CreateCommandQueue(&amp;queueDesc, IID_PPV_ARGS(&amp;m_pCommandQueue)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Describe and Create the swap chain</span></span><br><span class="line">	DXGI_SWAP_CHAIN_DESC swapChainDesc =&#123;&#125;;</span><br><span class="line">	swapChainDesc.BufferCount       = FrameCount;</span><br><span class="line">	swapChainDesc.BufferDesc.Width  = m_ScreenWidth;</span><br><span class="line">	swapChainDesc.BufferDesc.Height = m_ScreenHeight;</span><br><span class="line">	swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line">	swapChainDesc.BufferUsage       = DXGI_USAGE_RENDER_TARGET_OUTPUT;</span><br><span class="line">	swapChainDesc.SwapEffect        = DXGI_SWAP_EFFECT_FLIP_DISCARD;</span><br><span class="line">	swapChainDesc.OutputWindow      = GetHwnd();</span><br><span class="line">	swapChainDesc.SampleDesc.Count  = <span class="number">1</span>;</span><br><span class="line">	swapChainDesc.Windowed          = TRUE;</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;IDXGISwapChain&gt; pSwapChain;</span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(pFactory-&gt;</span>CreateSwapChain(</span><br><span class="line">		m_pCommandQueue.Get(),		<span class="comment">// Swap chain needs the queue so that it can force a flush on it.</span></span><br><span class="line">		&amp;swapChainDesc,</span><br><span class="line">		&amp;pSwapChain</span><br><span class="line">		)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	ThrowIfFailed(pSwapChain.As(&amp;m_pSwapChain));</span><br><span class="line">	<span class="function"><span class="title">m_FrameIndex</span> = m_pSwapChain-&gt;</span>GetCurrentBackBufferIndex();</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////// Create Decriptor heaps /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc =&#123;&#125;;</span><br><span class="line">		rtvHeapDesc.NumDescriptors = FrameCount;</span><br><span class="line">		rtvHeapDesc.Type           = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;</span><br><span class="line">		rtvHeapDesc.Flags          = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line"></span><br><span class="line">		T<span class="function"><span class="title">hrowIfFailed</span>(m_pD3D12Device-&gt;</span>CreateDescriptorHeap(&amp;rtvHeapDesc, IID_PPV_ARGS(&amp;m_pRTVHeap)));</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">m_RTVDescriptorSize</span> = m_pD3D12Device-&gt;</span>GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Create frame resources</span></span><br><span class="line">	&#123;</span><br><span class="line">		CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="function"><span class="title">rtvHandle</span>(m_pRTVHeap-&gt;</span>GetCPUDescriptorHandleForHeapStart());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a RTV for each frame.</span></span><br><span class="line">		<span class="keyword">for</span> (UINT n = <span class="number">0</span>; n &lt; FrameCount; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			T<span class="function"><span class="title">hrowIfFailed</span>(m_pSwapChain-&gt;</span>GetBuffer(n, IID_PPV_ARGS(&amp;m_pRenderTargets[n])));</span><br><span class="line">			<span class="function"><span class="title">m_pD3D12Device</span>-&gt;</span>CreateRenderTargetView(m_pRenderTargets[n].Get(), nullptr, rtvHandle);</span><br><span class="line">			rtvHandle.Offset(<span class="number">1</span>, m_RTVDescriptorSize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//The command allocator is going to be used for allocating memory for the list of commands that we send to the GPU each frame to render graphics.</span></span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pD3D12Device-&gt;</span>CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&amp;m_pCommandAllocator)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void RenderSysem::LoadAssets()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Create the command list.</span></span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pD3D12Device-&gt;</span>CreateCommandList(<span class="number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_pCommandAllocator.Get(), nullptr, IID_PPV_ARGS(&amp;m_pCommandList)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Command lists are created in the recording state, but there is nothing</span></span><br><span class="line">	<span class="comment">// to record yet. The main loop expects it to be closed, so close it now.</span></span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pCommandList-&gt;</span>Close());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create synchronization objects.</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// We use the fence as a signaling mechanism to notify us when the GPU is completely done rendering the command list that we submitted via the command queue</span></span><br><span class="line">		T<span class="function"><span class="title">hrowIfFailed</span>(m_pD3D12Device-&gt;</span>CreateFence(<span class="number">0</span>, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&amp;m_pD3D12Fence)));</span><br><span class="line">		m_FenceValue = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create an event handle to use for frame synchronization.</span></span><br><span class="line">		m_FenceEvent = CreateEventEx(nullptr, FALSE, FALSE, EVENT_ALL_ACCESS);</span><br><span class="line">		<span class="keyword">if</span> (m_FenceEvent == nullptr)</span><br><span class="line">		&#123;</span><br><span class="line">			ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Wait for the command list to execute; we are reusing the same command</span></span><br><span class="line">		<span class="comment">// list in our main loop but for now, we just want to wait for setup to</span></span><br><span class="line">		<span class="comment">// complete before continuing.</span></span><br><span class="line">		WaitForPreviousFrame();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void RenderSysem::PopulateCommandList()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Command list allocators can only be reset when the associated</span></span><br><span class="line">	<span class="comment">// command lists have finished execution on the GPU; apps should use</span></span><br><span class="line">	<span class="comment">// fences to determine GPU execution progress.</span></span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pCommandAllocator-&gt;</span>Reset());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// However, when ExecuteCommandList() is called on a particular command</span></span><br><span class="line">	<span class="comment">// list, that command list can then be reset at any time and must be before</span></span><br><span class="line">	<span class="comment">// re-recording.</span></span><br><span class="line">	auto pPipelineState = m_Triangle.GetPipelineState();</span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pCommandList-&gt;</span>Reset(m_pCommandAllocator.Get(), pPipelineState.Get()));</span><br><span class="line">	auto pRootSignature = m_Triangle.GetRootSignature();</span><br><span class="line">	<span class="function"><span class="title">m_pCommandList</span>-&gt;</span>SetGraphicsRootSignature(pRootSignature.Get());</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">m_pCommandList</span>-&gt;</span>RSSetViewports(<span class="number">1</span>, &amp;m_Viewport);</span><br><span class="line">	<span class="function"><span class="title">m_pCommandList</span>-&gt;</span>RSSetScissorRects(<span class="number">1</span>, &amp;m_ScissorRect);</span><br><span class="line">	<span class="function"><span class="title">m_pCommandList</span>-&gt;</span>ResourceBarrier(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_pRenderTargets[m_FrameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));</span><br><span class="line"></span><br><span class="line">	CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="function"><span class="title">rtvHandle</span>(m_pRTVHeap-&gt;</span>GetCPUDescriptorHandleForHeapStart(), m_FrameIndex, m_RTVDescriptorSize);</span><br><span class="line">	<span class="function"><span class="title">m_pCommandList</span>-&gt;</span>OMSetRenderTargets(<span class="number">1</span>, &amp;rtvHandle, FALSE, nullptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record commands.</span></span><br><span class="line">	const float clearColor[] =&#123; <span class="number">0.0</span>f, <span class="number">0.2</span>f, <span class="number">0.4</span>f, <span class="number">1.0</span>f &#125;;</span><br><span class="line">	<span class="function"><span class="title">m_pCommandList</span>-&gt;</span>ClearRenderTargetView(rtvHandle, clearColor, <span class="number">0</span>, nullptr);</span><br><span class="line"></span><br><span class="line">	m_Triangle.Render(m_pCommandList);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pCIndicate that the back buffer will now be used to present.</span></span><br><span class="line">	<span class="function"><span class="title">m_pCommandList</span>-&gt;</span>ResourceBarrier(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_pRenderTargets[m_FrameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));</span><br><span class="line"></span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pCommandList-&gt;</span>Close());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void  RenderSysem::WaitForPreviousFrame()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// WAITING FOR THE FRAME TO COMPLETE BEFORE CONTINUING IS NOT BEST PRACTICE.</span></span><br><span class="line">	<span class="comment">// This is code implemented as such for simplicity. More advanced samples</span></span><br><span class="line">	<span class="comment">// illustrate how to use fences for efficient resource usage.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Signal and increment the fence value.</span></span><br><span class="line">	const UINT64 fence = m_FenceValue;</span><br><span class="line">	T<span class="function"><span class="title">hrowIfFailed</span>(m_pCommandQueue-&gt;</span>Signal(m_pD3D12Fence.Get(), fence));</span><br><span class="line">	m_FenceValue++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait until the previous frame is finished.</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (m_pD3D12Fence-&gt;</span>GetCompletedValue() &lt; fence)</span><br><span class="line">	&#123;</span><br><span class="line">		T<span class="function"><span class="title">hrowIfFailed</span>(m_pD3D12Fence-&gt;</span>SetEventOnCompletion(fence, m_FenceEvent));</span><br><span class="line">		WaitForSingleObject(m_FenceEvent, INFINITE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">m_FrameIndex</span> = m_pSwapChain-&gt;</span>GetCurrentBackBufferIndex();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Triangle部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Triangle_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Triangle_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d3d12.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DirectXMath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Microsoft::WRL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> byhj</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Triangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Render</span><span class="params">(ComPtr&lt;ID3D12GraphicsCommandList&gt; pCommandList)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	ComPtr&lt;ID3D12PipelineState&gt; GetPipelineState()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_pPipelineState;</span><br><span class="line">	&#125;</span><br><span class="line">	ComPtr&lt;ID3D12RootSignature&gt; GetRootSignature()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_pRootSignature;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init_buffer</span><span class="params">(ComPtr&lt;ID3D12Device&gt; pD3D12Device)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init_shader</span><span class="params">(ComPtr&lt;ID3D12Device&gt; pD3D12Device)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> Vertex</span><br><span class="line">	&#123;</span><br><span class="line">		XMFLOAT3 position;</span><br><span class="line">		XMFLOAT4 color;</span><br><span class="line">	&#125;;</span><br><span class="line">	ComPtr&lt;ID3D12PipelineState&gt;  m_pPipelineState;</span><br><span class="line">	ComPtr&lt;ID3D12RootSignature&gt;  m_pRootSignature;</span><br><span class="line">	ComPtr&lt;ID3D12Resource&gt;       m_pVertexBuffer;</span><br><span class="line">	D3D12_VERTEX_BUFFER_VIEW     m_VertexBufferView;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>Triangle实现部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Triangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"d3dx12.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"d3d/Utility.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d3dcompiler.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> byhj</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::Init()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::Update()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::Render(ComPtr&lt;ID3D12GraphicsCommandList&gt; pCommandList)</span><br><span class="line">&#123;</span><br><span class="line">	pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);</span><br><span class="line">	pCommandList-&gt;IASetVertexBuffers(<span class="number">0</span>, <span class="number">1</span>, &amp;m_VertexBufferView);</span><br><span class="line">	pCommandList-&gt;DrawInstanced(<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::Shutdown()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::init_buffer(ComPtr&lt;ID3D12Device&gt; pD3D12Device)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create the vertex buffer.</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Define the geometry for a triangle.</span></span><br><span class="line">		Vertex triangleVertices[] =</span><br><span class="line">		&#123;</span><br><span class="line">			&#123; &#123;  <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125; &#125;,</span><br><span class="line">			&#123; &#123;  <span class="number">0.5f</span>, <span class="number">-0.5</span>f, <span class="number">0.0f</span> &#125;, &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125; &#125;,</span><br><span class="line">			&#123; &#123; <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0f</span> &#125;, &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125; &#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> UINT vertexBufferSize = <span class="keyword">sizeof</span>(triangleVertices);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">Note:</span> using upload heaps to transfer static data like vert buffers is not</span></span><br><span class="line">		<span class="comment">// recommended. Every time the GPU needs it, the upload heap will be marshalled</span></span><br><span class="line">		<span class="comment">// over. Please read up on Default Heap usage. An upload heap is used here for</span></span><br><span class="line">		<span class="comment">// code simplicity and because there are very few verts to actually transfer.</span></span><br><span class="line">		ThrowIfFailed(pD3D12Device-&gt;CreateCommittedResource(</span><br><span class="line">			&amp;CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),</span><br><span class="line">			D3D12_HEAP_FLAG_NONE,</span><br><span class="line">			&amp;CD3DX12_RESOURCE_DESC::Buffer(vertexBufferSize),</span><br><span class="line">			D3D12_RESOURCE_STATE_GENERIC_READ,</span><br><span class="line">			nullptr,</span><br><span class="line">			IID_PPV_ARGS(&amp;m_pVertexBuffer)));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Copy the triangle data to the vertex buffer.</span></span><br><span class="line">		UINT8* pVertexDataBegin;</span><br><span class="line">		ThrowIfFailed(m_pVertexBuffer-&gt;Map(<span class="number">0</span>, nullptr, reinterpret_cast&lt;void**&gt;(&amp;pVertexDataBegin)));</span><br><span class="line">		<span class="built_in">memcpy</span>(pVertexDataBegin, triangleVertices, <span class="keyword">sizeof</span>(triangleVertices));</span><br><span class="line">		m_pVertexBuffer-&gt;Unmap(<span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize the vertex buffer view.</span></span><br><span class="line">		m_VertexBufferView.BufferLocation = m_pVertexBuffer-&gt;GetGPUVirtualAddress();</span><br><span class="line">		m_VertexBufferView.StrideInBytes = <span class="keyword">sizeof</span>(Vertex);</span><br><span class="line">		m_VertexBufferView.SizeInBytes = vertexBufferSize;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::init_shader(ComPtr&lt;ID3D12Device&gt; pD3D12Device)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Create empty root signature</span></span><br><span class="line">	&#123;</span><br><span class="line">		CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;</span><br><span class="line">		rootSignatureDesc.Init(<span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);</span><br><span class="line"></span><br><span class="line">		ComPtr&lt;ID3DBlob&gt; signature;</span><br><span class="line">		ComPtr&lt;ID3DBlob&gt; error;</span><br><span class="line">		ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));</span><br><span class="line">		ThrowIfFailed(pD3D12Device-&gt;CreateRootSignature(<span class="number">0</span>, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(&amp;m_pRootSignature)));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create the pipeline state, which includes compiling and loading shaders.</span></span><br><span class="line">	&#123;</span><br><span class="line">		ComPtr&lt;ID3DBlob&gt; vertexShader;</span><br><span class="line">		ComPtr&lt;ID3DBlob&gt; pixelShader;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">		<span class="comment">// Enable better shader debugging with the graphics debugging tools.</span></span><br><span class="line">		UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		UINT compileFlags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		ThrowIfFailed(D3DCompileFromFile( <span class="string">L"triangle.vsh"</span>, nullptr, nullptr, <span class="string">"VS_MAIN"</span>, <span class="string">"vs_5_0"</span>, compileFlags, <span class="number">0</span>, &amp;vertexShader, nullptr));</span><br><span class="line">		ThrowIfFailed(D3DCompileFromFile( <span class="string">L"triangle.psh"</span>, nullptr, nullptr, <span class="string">"PS_MAIN"</span>, <span class="string">"ps_5_0"</span>, compileFlags, <span class="number">0</span>, &amp;pixelShader, nullptr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Define the vertex input layout.</span></span><br><span class="line">		D3D12_INPUT_ELEMENT_DESC inputElementDescs[] =</span><br><span class="line">		&#123;</span><br><span class="line">			&#123; <span class="string">"POSITION"</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="number">0</span>, <span class="number">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;,</span><br><span class="line">			&#123; <span class="string">"COLOR"</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="number">0</span>, <span class="number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Describe and create the graphics pipeline state object (PSO).</span></span><br><span class="line">		D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc =&#123;&#125;;</span><br><span class="line">		psoDesc.InputLayout =&#123; inputElementDescs, _countof(inputElementDescs) &#125;;</span><br><span class="line">		psoDesc.pRootSignature = m_pRootSignature.Get();</span><br><span class="line">		psoDesc.VS =&#123; <span class="keyword">reinterpret_cast</span>&lt;UINT8*&gt;(vertexShader-&gt;GetBufferPointer()), vertexShader-&gt;GetBufferSize() &#125;;</span><br><span class="line">		psoDesc.PS =&#123; <span class="keyword">reinterpret_cast</span>&lt;UINT8*&gt;(pixelShader-&gt;GetBufferPointer()), pixelShader-&gt;GetBufferSize() &#125;;</span><br><span class="line">		psoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);</span><br><span class="line">		psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);</span><br><span class="line">		psoDesc.DepthStencilState.DepthEnable = FALSE;</span><br><span class="line">		psoDesc.DepthStencilState.StencilEnable = FALSE;</span><br><span class="line">		psoDesc.SampleMask = UINT_MAX;</span><br><span class="line">		psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;</span><br><span class="line">		psoDesc.NumRenderTargets = <span class="number">1</span>;</span><br><span class="line">		psoDesc.RTVFormats[<span class="number">0</span>] = DXGI_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line">		psoDesc.SampleDesc.Count = <span class="number">1</span>;</span><br><span class="line">		ThrowIfFailed(pD3D12Device-&gt;CreateGraphicsPipelineState(&amp;psoDesc, IID_PPV_ARGS(&amp;m_pPipelineState)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><p>在这里Vertex Shader和Pixel Shader只是简单的传递顶点和颜色数据</p>
<h2 id="Vertex-Shader"><a href="#Vertex-Shader" class="headerlink" title="Vertex Shader"></a>Vertex Shader</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct VS_IN</span><br><span class="line">&#123;</span><br><span class="line">  float4 Pos  : POSITION<span class="comment">;</span></span><br><span class="line">  float4 Color: COLOR0<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">  float4 Pos   : SV_POSITION<span class="comment">;</span></span><br><span class="line">  float4 Color : COLOR0<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">VS_OUT VS_MAIN( VS_IN vs_in)</span><br><span class="line">&#123;</span><br><span class="line">  VS_OUT vs_out<span class="comment">;</span></span><br><span class="line">  vs_out.Pos   = vs_in.Pos<span class="comment">;</span></span><br><span class="line">  vs_out.Color = vs_in.Color<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  return vs_out<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pixel-Shader"><a href="#Pixel-Shader" class="headerlink" title="Pixel Shader"></a>Pixel Shader</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">VS_OUT</span></span><br><span class="line">&#123;</span><br><span class="line">  float4 <span class="attribute">Pos   </span>: SV_POSITION;</span><br><span class="line">  float4 <span class="attribute">Color </span>: COLOR0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">float4</span> <span class="selector-tag">PS_MAIN</span>( VS_OUT vs_out) <span class="selector-pseudo">:SV_TARGET</span></span><br><span class="line">&#123;</span><br><span class="line">  return vs_out<span class="selector-class">.Color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DirectX-Tutorials]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/18/Direct3D-Tutorials/</url>
      <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="DirectX-12"><a href="#DirectX-12" class="headerlink" title="DirectX 12"></a>DirectX 12</h2><ul>
<li><a href="https://software.intel.com/en-us/articles/tutorial-migrating-your-apps-to-directx-12-part-1" target="_blank" rel="external">Migrating Your Apps to DirectX 12</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903821(v=vs.85" target="_blank" rel="external">Direct3D 12 Graphics</a>)</li>
<li><a href="https://digitalerr0r.wordpress.com/2015/08/19/quickstart-directx-12-programming" target="_blank" rel="external">DirectX 12 Programming #1: A quickstart!</a></li>
</ul>
<h2 id="DirectX-10-amp-11"><a href="#DirectX-10-amp-11" class="headerlink" title="DirectX 10&amp;11"></a>DirectX 10&amp;11</h2><ul>
<li><a href="http://www.rastertek.com/" target="_blank" rel="external">www.rastertek.com</a>里面框架构建得太复杂，总体来说还是挺好的教程，同时还有Terrain的部分。</li>
<li><a href="http://www.braynzarsoft.net/" target="_blank" rel="external">www.braynzarsoft.net</a>程序很多东西塞在一起，导致程序变得很长没有结构感。</li>
<li><a href="http://www.d3dcoder.net/" target="_blank" rel="external">www.d3dcoder.net</a>龙书官网</li>
<li><a href="https://takinginitiative.wordpress.com/directx10-tutorials/" target="_blank" rel="external">takinginitiative</a></li>
<li><a href="http://www.3dgep.com/category/graphics-programming/directx/" target="_blank" rel="external">3D Game Engine Programming</a></li>
<li><a href="http://richardssoftware.net/Home/DirectX11Tutorials" target="_blank" rel="external">SlimDX DirectX 11 Tutorials</a></li>
</ul>
<a id="more"></a>
<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee663274(v=vs.85" target="_blank" rel="external">DirectX Graphics and Gaming</a>) Microsoft的DirectX说明文档,旧版本DiectX11.0和之前版本的文档是随着DirectX SDK安装到本地的。</li>
<li><a href="http://blogs.msdn.com/b/directx/" target="_blank" rel="external">DirectX Developer Blog</a>DirectX官方博客</li>
</ul>
<h2 id="DirectX-9"><a href="#DirectX-9" class="headerlink" title="DirectX 9"></a>DirectX 9</h2><p>DirectX9主要看了龙书，没怎么了解其它网站的教程,分享一下我收藏的几个网站教程</p>
<ul>
<li><a href="http://www.chadvernon.com/blog/resources/directx9/" target="_blank" rel="external">www.chadvernon.com</a></li>
<li><a href="http://www.drunkenhyena.com/cgi-bin/directx.pl" target="_blank" rel="external">www.drunkenhyena.com</a></li>
<li><a href="http://www.riemers.net/eng/Tutorials/DirectX/Csharp/series3.php" target="_blank" rel="external">www.riemers.net</a></li>
<li><a href="http://directxworld.altervista.org/index.php?link=graphic_lessons" target="_blank" rel="external">directxworld.altervista.org</a></li>
</ul>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>在Windows 8.x中, DirectX SDK不在以单独的安装包提供，而是包含在Windows SDK里面。它不在支持旧版本的d3dx功能，下面这个文章可以帮助你进行过渡。</p>
<ul>
<li><a href="http://blogs.msdn.com/b/chuckw/archive/2013/08/21/living-without-d3dx.aspx" target="_blank" rel="external">Live Without D3DX</a></li>
<li><a href="http://blogs.msdn.com/b/chuckw/archive/2013/09/20/directx-sdk-samples-catalog.aspx" target="_blank" rel="external">DirectX SDK Samples Catalog</a></li>
<li><a href="http://blogs.msdn.com/b/chuckw/archive/2013/07/01/where-is-the-directx-sdk-2013-edition.aspx" target="_blank" rel="external">Where is the DirectX SDK (2013 Edition)?</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee415571(v=vs.85" target="_blank" rel="external">DirectXMath Programming Guide</a> )</li>
<li>【】 <a href="https://msdn.microsoft.com/library/windows/apps/hh452744" target="_blank" rel="external">https://msdn.microsoft.com/library/windows/apps/hh452744</a></li>
</ul>
<hr>
<h1 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h1><ul>
<li>Introduction to 3D Game Programming with DirectX 9.0</li>
<li>Introduction to 3D Game Programming with DirectX 9.0c: A Shader Approach</li>
<li>Introduction to 3D Game Programming with Direct3D 10.0</li>
<li>Introduction to 3D Game Programming with Direct3D 11.0</li>
</ul>
<hr>
<h1 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h1><ul>
<li><a href="https://channel9.msdn.com/Series/ConnectOn-Demand/212" target="_blank" rel="external">DirectX Tools for Windows 10 in Visual Studio 2015</a></li>
<li><a href="http://blogs.msdn.com/b/chuckw/archive/2014/10/28/directx-sdk-tools-catalog.aspx" target="_blank" rel="external">DirectX SDK Tools Catalog</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/hh315751.aspx" target="_blank" rel="external">Visual Studio Graphics Diagnostics</a></li>
</ul>
<hr>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Books]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/18/Books/</url>
      <content type="html"><![CDATA[<p>重返巴比伦          (美)斯科特•菲茨杰拉德<br>人格心理学          (美)Jerry M.Burger<br>当代心理学体系      (美)Noel W.Smith<br>沉思录              (古罗马)马可•奥勒留<br>生命的意志          (德)尼采<br>生存空虚说          (德)叔本华<br>查拉图斯特拉如是说   (德)尼采<br>繁花将尽            (美)劳伦斯•布洛克</p>
<a id="more"></a>
<p>压力管理心理学       (美)沃特•谢弗尔<br>快乐的知识          (德)尼采<br>什么是快乐的人生     (英)罗素<br>幻梦的残片          (美) 斯科特•菲茨杰拉德<br>得与失的智慧        (德)叔本华<br>酒店关门之后         (美)劳伦斯•布洛克<br>夜色温柔           (美)菲茨杰拉德<br>哲学的慰藉          (古罗马)波爱修斯<br>行过死荫之地         (美)劳伦斯•布洛克<br>生活之路           (俄)列夫•托尔斯泰<br>向邪恶追索          (美)劳伦斯•布洛克<br>了不起的盖茨比        (美)菲茨杰拉德<br>美丽和毁灭          (美)菲茨杰拉德<br>思想录                （法）帕斯卡尔<br>瓦尔登湖               （美）亨利•大卫•梭罗<br>Pinocchio          （意）科洛迪<br>睡不着的密探         (美)  劳伦斯•布洛克著<br>最后的大亨          (美)菲茨杰拉德著<br>一梦十年           (美) 菲茨杰拉德著<br>冷月                 （美）杰弗里•迪弗著<br>失落的秘符          (美)丹•布朗(Dan Brown)著<br>狄德罗经典文存            （法)狄德罗<br>日常生活心理学        (美)里克•M•加德纳著<br>蓝色骇客           (美)杰夫里•迪弗著<br>恶魔的泪珠          (美)杰夫里•迪弗著<br>棺材舞者           (美) 杰夫里•迪弗著<br>柏拉图对话集         (古希腊)柏拉图著<br>小城             (美)劳伦斯•布洛克著<br>教育心理学          (美)Jeanne Ellis ormrod著<br>感动世界的50首歌和他们背后的故事 朱睿竑编著</p>
<p>别离的笙箫  徐志摩著<br>假如给我三天光明           （美）海伦凯勒<br>乞力马扎罗的雪            （美）海明威著<br>亲密关系               （美）Rowland S.Miller / Daniel Perlman著<br>凯尔特的薄暮             （爱尔兰）W.B.叶芝著<br>比爱更爱你  青年文摘30年典藏文<br>一生的学习  克利希那穆提著<br>你应该知道的世界思想名著   (英)汉默顿著<br>心灵漫步           (美) 亨利•大卫•梭罗著<br>人生中不可不想的事 克利希那穆提著<br>有节制的生活         (古罗马)马尔库斯•图利乌斯•西塞罗著<br>一个孤独漫步者的遐想     (法) 让 - 雅克•卢梭著<br>河上一周           (美) 亨利•大卫•梭罗著<br>心灵自由之路         (印)克里希那穆提著<br>面包里的幸福人生       (古罗马)吕齐乌斯•安涅•塞涅卡著<br>大师教你生活之道  爱比克泰德语录<br>心理学与我们         (美) 罗伯特•费尔德曼, 黄希庭著<br>培根论人生          (英)培根著<br>你不可不读的西方哲学故事 文聘元著<br>缅因森林           (美)亨利•大卫•梭罗著<br>济慈诗选  济慈著<br>华兹华斯歌精选  华兹华斯著<br>哲学研究           (英) 路德维希•维特根斯坦著<br>蓝皮书和褐皮书        (英) 路德维希•维特根斯坦著</p>
<p>教育与科学              （英）怀特海<br>茶花女                （法）小仲马<br>叔本华的智慧   (德)叔本华原著；<br>我们缺什么   (德)弗里德里希•威廉•尼采著<br>自以为是鲍嘉的贼    (美)劳伦斯•布洛克著<br>风景中的人类    (德)叔本华著；<br>一滴烈酒   (美)劳伦斯•布洛克著<br>爱与寂寞   (印度)克里希那穆提著<br>神曲                 （地狱篇） (意) 但丁•阿利格耶里著<br>傲慢与偏见    (英)简•奥斯丁<br>爱玛            (英)简•奥斯丁<br>曼斯菲尔德庄园   (英)简•奥斯丁</p>
<p>万国风情丛书，文化随笔系列之<br>梦幻国度的声音            （法国）<br>绅士的格调              （英国）<br>伏特加酒之歌             （俄罗斯）<br>鹰隼的目光              （美国）<br>黑森林之风              （德国，奥地利，瑞士）<br>风流樱花雨              （日本）</p>
<p>卡夫卡散文  (奥)卡夫卡著<br>生命的重建 (美)露易丝•海(Louise L.Hay)著<br>神曲                 （炼狱篇） (意) 但丁•阿利格耶里著<br>神曲                 （天堂篇） (意) 但丁•阿利格耶里著<br>维特根斯坦论伦理学与哲学   (英)维特根斯坦著<br>路边十字架(美)    杰弗里•迪弗著<br>维特根斯坦剑桥讲演录  (英)维特根斯坦著<br>快乐的知识   (德)尼采著<br>权力意志               （上）   (德)尼采著<br>权力意志               （下）   (德)尼采著<br>爱与寂寞 (印)克里希那穆提著</p>
<p>追忆逝水年华– - 在斯万家这边  （法）M.普鲁斯特<br>追忆逝水年华– - 在花季少女倩影下（法）M.普鲁斯特<br>追忆逝水年华– - 盖尔芒特家那边 （法）M.普鲁斯特<br>追忆逝水年华– - 索多姆和戈摩尔 （法）M.普鲁斯特<br>追忆逝水年华– - 女囚      （法）M.普鲁斯特<br>追忆逝水年华– - 女逃亡者    （法）M.普鲁斯特<br>追忆逝水年华– - 重现的时光   （法）M.普鲁斯特</p>
<p>Adolescence   ／Laurence Steinberg<br>Understanding psychology   ／Robert S.Feldman.<br>THE BRITISH writers’lives - John Keats</p>
<p>浮士德                （德）歌德<br>城堡     (奥)卡夫卡著<br>彼岸花   安妮宝贝<br>告别薇安  安妮宝贝</p>
<p>万物静默如谜<br>我曾这样寂寞生活<br>远行</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[More Effective C++总结]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/17/MoreEffectiveC++/</url>
      <content type="html"><![CDATA[<h1 id="基础议题"><a href="#基础议题" class="headerlink" title="基础议题"></a>基础议题</h1><h2 id="仔细区别pointers和references"><a href="#仔细区别pointers和references" class="headerlink" title="仔细区别pointers和references"></a>仔细区别pointers和references</h2><p>Pointers和references在某些方面做着同样的事情，但两者还是有所区别：<br>　　没有null reference但是有null pointers，reference总是代表着某个对象，是另一个对象的别名，reference的这一语法特定<br>使得在使用reference之前不需要测试其有效性，在一定程度上提高了效率。在另一方面，pointers可以被重新赋值，指向另一个对象，<br>而reference总是指向（代表）它最初获得的那个对象。在实现某些操作符，例如operator[], 使用reference能够比较自然得到<br>“被当做assignment赋值对象”的功能。</p>
 <a id="more"></a>
<h2 id="最好使用C-转型操作符"><a href="#最好使用C-转型操作符" class="headerlink" title="最好使用C++转型操作符"></a>最好使用C++转型操作符</h2><p>　　由于旧式C语言的转型几乎可以将任何类型转换为其它类型，而没有给出每次转型更精确的意图，加上旧式转型的小括号方式在程序中可能难以辨识，所以最好才采用C++新的转型类型操作符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">static_cast</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure></p>
<p>　　这是静态类型转换操作，允许基本类型之间的相互转换，但不能移除表达式的常量性，我们采用下面转换来改变表达式的常量性或易变性，这个操作由编译器执行。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">const_cast</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure></p>
<p>　　但要执行继承体系中“安全的向下转型或跨系转型动作”时，使用下面动态类型转换符。需要注意的是它无法应用在缺乏虚函数的类型身上，也不能改变类型的常量性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">dynamic_cast</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure></p>
<p>　　最后一种转型操作几乎与编译平台相关，所以它不具备移植性，我们常用它来进行转换“函数指针”类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">reinterpret_cast</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure></p>
<p>　　当你的编译平台不能支持新式转型操作时，你可以考虑采用宏去模拟这些语法：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define static_cast(<span class="name">TYPE</span>, EXPR)       ((<span class="name">TYPE</span>) (<span class="name">EXPR</span>))</span><br><span class="line">#define const_cast(<span class="name">TYPE</span>, EXPR)        ((<span class="name">TYPE</span>) (<span class="name">EXPR</span>))</span><br><span class="line">#define reinterpret_cast(<span class="name">TYPE</span>, EXPR)  ((<span class="name">TYPE</span>) (<span class="name">EXPR</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="绝对不要以多态方式处理数组"><a href="#绝对不要以多态方式处理数组" class="headerlink" title="绝对不要以多态方式处理数组"></a>绝对不要以多态方式处理数组</h2><p>　　多态和指针算术不能混用，数组访问时是指针算术表达式。通过base class指针删除一个由derived classes objects构成的数组，，其结果未定义。<br>当以数组形式传递时，编译器对数组对象的理解是声明的部分，而不是你想要的多态效果。</p>
<h2 id="非必要不提供default-constructor"><a href="#非必要不提供default-constructor" class="headerlink" title="非必要不提供default constructor"></a>非必要不提供default constructor</h2><p>　　default constructor在没有任何外来信息的情况将对象初始化，当现实世界往往需要外来信息进行操作。当你不提供default constructor时,<br>没有方法为数组对象指定constructor自变量，它们同样将不适用于许多template-based container classes.虽然有着这些限制，但是在一般情况下还是<br>不要提供default constructor。</p>
<hr>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="对定制的“类型转换函数”保持警觉"><a href="#对定制的“类型转换函数”保持警觉" class="headerlink" title="对定制的“类型转换函数”保持警觉"></a>对定制的“类型转换函数”保持警觉</h2><p>　　C++允许编译器在不同类型之间执行隐式转换。类型转换的问题在于，在你从未打算也未预期的情况下，此类函数可能会被调用，而其结果可能是不正确<br>，不直观的程序行为，很难调试。存在着两种函数转换：</p>
<ul>
<li><p>隐式类型转换操作符 ：关键词operator后加上一个类型名称<br>　　这类转换我们可以将operator的重载换成显式的转换专有函数，string的c_str()函数就是个很好的例子。</p>
</li>
<li><p>单变量constructors函数：会执行隐式的转换为类对象<br>　　使用explicit能够避免这一问题，编译器不能因隐式类型转换的需要调用它们，但是你还是可以通过显式类型的转换。当你无法使用explicit时，可以使用<br>proxy技术，将单一参数转换为一个内部类表示，这样做的话就可以执行原来的构造函数又避免类型转换动作，因为这样的转换需要两次，不合法。</p>
</li>
</ul>
<h2 id="区分increment-decrement操作符的前置和后置形式"><a href="#区分increment-decrement操作符的前置和后置形式" class="headerlink" title="区分increment / decrement操作符的前置和后置形式"></a>区分increment / decrement操作符的前置和后置形式</h2><p>　　通过添加一个int自变量进行后置版本的识别，编译器会为此int指定为0值，前置式返回一个reference，后置式返回返回一个const对象。<br>后置式返回的const能够阻止++++之类的操作，这种操作和内建类型的行为不一致，即使可以这样其行为也不是你预期那样。除此之外，后置<br>版本返回原来的副本也会对效率带来影响。</p>
<h2 id="千万不要重载-amp-amp-和-，操作符"><a href="#千万不要重载-amp-amp-和-，操作符" class="headerlink" title="千万不要重载 &amp;&amp; || 和 ，操作符"></a>千万不要重载 &amp;&amp; || 和 ，操作符</h2><p>　　重载这些操作符会让程序从短路求值语意向函数调用转变，这两者是不同的。当函数调用动作被执行，所有参数值都必须评估完成。C++语言规范并未<br>明确定义函数调用动作中各参数的评估顺序。对于逗号表达式，从左往右进行评估，最后整个逗号表达式的结果以逗号右侧的值为代表。而当你重载逗号<br>操作符后，不能得到这些保证。</p>
<h2 id="了解各种不同意义的new和delete"><a href="#了解各种不同意义的new和delete" class="headerlink" title="了解各种不同意义的new和delete"></a>了解各种不同意义的new和delete</h2><p>　　new operator由语言内置，不能被改变意义，总是做相同的事情：</p>
<ul>
<li>它分配足够的内存，用来放置某些类型的对象。</li>
<li>调用一个constructor，为刚才分配的内存中的那个对象设定初值。<br>　　你能够进行改变的时用来容纳对象的那块内存的分配行为，new operator调用某个函数，执行必要的内存分配动作，你可以重写或重载那个函数，改变其行为。<br>这个函数称为operator new.</li>
</ul>
<p>‘’’<br>void * operator new(size_t size);</p>
<p>‘’’<br>返回一个指针，指向一块原始的，未设初值的内存，当你重载这个operator new时，size_t是必须的第一参数。它只负责分配内存，不进行初始化。<br>你可以使用placement new对分配好的原始内存，在上面构建对象。</p>
<p>　　为了避免资源泄露，每一个动态分配行为都必须匹配一个相应但相反的释放动作，operator delete对于内建的delete operator关系与上面类似。<br>内存释放动作由函数operator delete执行，如果你只打算处理原始的，未设初值的内存，应该使用operator new和operator delete(相当于malloc和free)，<br>而不是new operator和delete operator.<br>　　数组版本的new还是那个new operator但内存以一个名为operator new[]的函数进行分配内存（array new)，delete也是同样的道理。数组版与单一版的<br>new operator所调用的constructor数量不同。</p>
<hr>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="利用destructors避免内存泄露"><a href="#利用destructors避免内存泄露" class="headerlink" title="利用destructors避免内存泄露"></a>利用destructors避免内存泄露</h2><p>　　以一个对象存放“必须自动释放的资源”并依赖该对象的destructor释放，可以在exceptions出现时避免资源泄露。</p>
<h2 id="在constructors内阻止资源泄露"><a href="#在constructors内阻止资源泄露" class="headerlink" title="在constructors内阻止资源泄露"></a>在constructors内阻止资源泄露</h2><p>　　exception的发生可能由于operator new无法分配足够内存时，这时控制权被移出constructor之外，而析构函数对已构造完成的对象才进行<br>释放操作。这个时候，我们需要将所有可能的exceptioons捕捉起来，执行某些清理工作，然后从新抛出exception使它继续传播出去。当member initialization\<br>lists时，把try catch放在private member functions内，然后进行处理。</p>
<h2 id="禁止异常流出destructors之外"><a href="#禁止异常流出destructors之外" class="headerlink" title="禁止异常流出destructors之外"></a>禁止异常流出destructors之外</h2><p>　　destructor在两种情况下会被调用：</p>
<ul>
<li>当对象在正常状态下被销毁，也就是当它离开了它的生存空间或是被明确地删除</li>
<li>当对象在exception处理机制的statck-unwinding(展开)机制-销毁<br>可以避免terminate函数在exception传播过程的stack-unwinding， 可以协助确保destructors完成其应该完成的所有的事情。</li>
</ul>
<h2 id="了解“抛出一个exception”与”传递一个参数”或“调用一个虚函数”之间的差异"><a href="#了解“抛出一个exception”与”传递一个参数”或“调用一个虚函数”之间的差异" class="headerlink" title="了解“抛出一个exception”与”传递一个参数”或“调用一个虚函数”之间的差异"></a>了解“抛出一个exception”与”传递一个参数”或“调用一个虚函数”之间的差异</h2><p>　　函数参数和exceptions的传递方式都有三种，by value, vy reference, by pointer。但是你调用一个函数，控制权最终会回到调用端。<br>而当你抛出一个exception,控制权不会再回到抛出端。不论exception是以哪种方式参数传递，都会发生复制行为，catch得到是副本，这个复制行为<br>是由对象的copy constructor执行的，该复制动作永远是以对象的静态类型为本。<br>　　exceptions与catch子句相匹配过程中，仅有两种转换可以发生：</p>
<ul>
<li>继承架构中的类转换</li>
<li>从一个“有型指针”转为”无型指针”</li>
</ul>
<h2 id="以by-reference方式捕捉exceptions"><a href="#以by-reference方式捕捉exceptions" class="headerlink" title="以by reference方式捕捉exceptions"></a>以by reference方式捕捉exceptions</h2><p>　　catch by reference可以避免对象删除问题。</p>
<h2 id="明智运用exception-specifications"><a href="#明智运用exception-specifications" class="headerlink" title="明智运用exception specifications"></a>明智运用exception specifications</h2><h2 id="了解异常处理的成本"><a href="#了解异常处理的成本" class="headerlink" title="了解异常处理的成本"></a>了解异常处理的成本</h2><ul>
<li>必须付出一些空间，放置某些数据结构（记录着那些对象已被完全构造）</li>
<li>try语句块</li>
</ul>
<hr>
<h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><h2 id="谨记80-20法则"><a href="#谨记80-20法则" class="headerlink" title="谨记80-20法则"></a>谨记80-20法则</h2><p>　　软件的整体性能几乎总是有其构成要素的一小部分决定。借助程序分析器查找出瓶颈在哪一部分，然后再进行优化。</p>
<h2 id="考虑使用lazy-evaluation-缓式评估"><a href="#考虑使用lazy-evaluation-缓式评估" class="headerlink" title="考虑使用lazy evaluation(缓式评估)"></a>考虑使用lazy evaluation(缓式评估)</h2><ul>
<li>Reference Counting (引用计数) ：在你真正需要之前，不必着急为某物做一个副本，可以采用拖延政策直到需要修改时才提供副本操作。</li>
<li>区分读和写 ： operator[]的读写区分</li>
<li>Lazy Fetching（缓式取出）：避免非必要的数据库读取动作</li>
<li>Lazy Expression Evaluation(表达式缓评估) ：避免不必要的数值计算动作</li>
</ul>
<h2 id="分期摊还预期的计算成本。"><a href="#分期摊还预期的计算成本。" class="headerlink" title="分期摊还预期的计算成本。"></a>分期摊还预期的计算成本。</h2><p>   超急评估：令他超前进度地做“要求以外”的更多工作。<br>   如果你预期程序常常会用到某个计算，你可以降低每次计算的平均成本，办法就是设计一份数据结构以便能够极有效率地处理需求。<br>  Catching和prefetching(预先取出)都是其中的案例。<br>  但是较佳往往导致较大的内存成本。</p>
<h2 id="了解临时对象的来源"><a href="#了解临时对象的来源" class="headerlink" title="了解临时对象的来源"></a>了解临时对象的来源</h2><p>　　C++中真正的临时对象时不可见的，由编译器隐式调用生成。一般而言，函数调用时隐式转换和函数返回对象时会生成这类对象。<br>你可以声明reference-to-const避免这类问题。</p>
<h2 id="协助完成返回值优化（RVO"><a href="#协助完成返回值优化（RVO" class="headerlink" title="协助完成返回值优化（RVO)"></a>协助完成返回值优化（RVO)</h2><p>　　编译器在返回对象时，可以执行返回值优化。<br>‘’’<br>const TestClass operator+(const TestClass &amp;lhs, const TestClass &amp;rhs) {<br>  return TestClass(lhs.val + rhs.val);<br>}<br>‘’’</p>
<h2 id="利用重载技术避免隐式类型转换"><a href="#利用重载技术避免隐式类型转换" class="headerlink" title="利用重载技术避免隐式类型转换"></a>利用重载技术避免隐式类型转换</h2><p>　　每个重载操作符必须获得至少一个用户定制的自变量，我们可以通过提供多种参数的重载函数避免临时对象的生成。</p>
<h2 id="考虑以操作符复合形式取代其独身形式"><a href="#考虑以操作符复合形式取代其独身形式" class="headerlink" title="考虑以操作符复合形式取代其独身形式"></a>考虑以操作符复合形式取代其独身形式</h2><p>　　我们一般使用复合形式来实现operator的单一版本，单一版本需要返回一个新对象，而复合版本则是直接将结果写入<br>其左端自变量，不需要产生一个临时对象来放置返回值。</p>
<h2 id="考虑使用其他程序库"><a href="#考虑使用其他程序库" class="headerlink" title="考虑使用其他程序库"></a>考虑使用其他程序库</h2><p>　　C++的IO操作比C的慢很多，可以视情况选择合适的程序库。</p>
<h2 id="了解virtual-functions-multiple-inheritance-virtual-base-class-runtime-type-identification的成本"><a href="#了解virtual-functions-multiple-inheritance-virtual-base-class-runtime-type-identification的成本" class="headerlink" title="了解virtual functions, multiple inheritance, virtual base class, runtime type identification的成本"></a>了解virtual functions, multiple inheritance, virtual base class, runtime type identification的成本</h2><p>　　vtbl和vptr需要额外的内存空间，换页动作由此受到影响。虚函数本身并不构成性能上的瓶颈，真正运行时期成本发生在inlining互动的时候。<br>多重继承往往导致virtual base classes虚拟基类的需要，这可能导致对象内的隐式指针增加。RTTI让我们在运行时期获得objects和classes的<br>相关信息，需要空间存储type_info信息，使用typeud去获得class的对应type_info，type_info放在vtbl中。</p>
<hr>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="将constructor-和-non-member-functions虚化"><a href="#将constructor-和-non-member-functions虚化" class="headerlink" title="将constructor 和 non-member functions虚化"></a>将constructor 和 non-member functions虚化</h2><p>　　virtual constructo是某种函数，视其获得的输入，可产生不同类型对象。从磁盘或者磁带读取对象信息经常被用到。</p>
<p>virtual copy constructor返回一个指针，指向其调用者的一个新副本，通常以clone()命名（Prototypee）。<br>当derived class重新定义其base class的一个虚函数时，不再需要一定得声明与原来相同的返回类型。<br>‘’’<br>class Base {<br>  virtual Base * clone() const = 0;<br>};</p>
<p>class A : public Base {<br>  virtual A <em> clone() const {<br>    return new A(</em>this);<br>  }<br>};</p>
<p>class B : public Base {<br>  virtual B <em> clone() const {<br>    return new B(</em>this);<br>  }<br>};</p>
<p>‘’’</p>
<p>non-member functions的虚化：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用函数。</p>
<p>‘’’<br>class Base {<br>  virtual ostream &amp; print(ostream &amp;s) const = 0;<br>};</p>
<p>class A : public Base {<br>  virtual ostream &amp; print(ostream &amp;s) const;<br>};</p>
<p>class B : public Base {<br>  virtual ostream &amp; print(ostream &amp;s) const;<br>};<br>inline ostream &amp;operator &lt;&lt; (ostream &amp;s, const Base &amp;b) {<br>  return b.print(s);<br>}</p>
<p>‘’’</p>
<h2 id="限制某个class所能产生的对象数量"><a href="#限制某个class所能产生的对象数量" class="headerlink" title="限制某个class所能产生的对象数量"></a>限制某个class所能产生的对象数量</h2><ul>
<li><p>允许零个或一个对象<br>阻止对象生成，只要将constructors声明为private，而利用单例模式static操作则可以生成一个对象。</p>
</li>
<li><p>不同的对象构造状态</p>
</li>
<li><p>允许对象生生灭灭</p>
</li>
<li><p>一个用来计算对象个数的base class</p>
</li>
</ul>
<h2 id="要求或禁止对象产生于heap之中"><a href="#要求或禁止对象产生于heap之中" class="headerlink" title="要求或禁止对象产生于heap之中"></a>要求或禁止对象产生于heap之中</h2><ul>
<li><p>要求对象产生于heap之中（head-based objects)<br>让destrutor成为private,而constructors为public,导入一个伪destructor函数调用真正的private。</p>
</li>
<li><p>判断某个对象是否位于heap中</p>
</li>
<li><p>禁止对象产生于heap之中<br>对象被直接实例化，对象被实例化为derived class objects内的base classes成分，对象被内嵌于其他对象之中。</p>
</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="proxy-classes代理类"><a href="#proxy-classes代理类" class="headerlink" title="proxy classes代理类"></a>proxy classes代理类</h2><p>　　用来代表其他对象的对象，称为proxy objects（替身对象）,而用以表现proxy objects者，我们称为proxy classes。</p>
<hr>
<h1 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h1><h2 id="在未来时态下发展程序"><a href="#在未来时态下发展程序" class="headerlink" title="在未来时态下发展程序"></a>在未来时态下发展程序</h2><p>　　好的软件对于变化有良好的适应能力。</p>
<ul>
<li>以C++本身(而非只是注释或说明文件)来表现各种规范</li>
<li>避免”demand-paged”式的虚函数</li>
<li>为每一个class处理assignment和copy construction动作</li>
<li>努力让classes的操作符和函数拥有自然的语法和直观的语义</li>
<li>让classes容易被正确使用，不容易被误用</li>
<li>努力写出可移植代码</li>
<li>设计你的代码，使：“系统改变所带来的冲击”得以局部化</li>
<li>提供完整的classes,即使某些部分目前用不到</li>
<li>设计你的接口，使有利于共同的操作行为，阻止共同的错误</li>
<li>尽量使你的代码一般化，除非有不良的巨大后果</li>
</ul>
<h2 id="将非尾端类（non-leaf-classes）设计为抽象类"><a href="#将非尾端类（non-leaf-classes）设计为抽象类" class="headerlink" title="将非尾端类（non-leaf classes）设计为抽象类"></a>将非尾端类（non-leaf classes）设计为抽象类</h2><p>　　让原来的继承base类成为子类，添加一个抽象基类，这样做可达到允许同型赋值，部分赋值和异型赋值都被禁止的功能。<br>我们可以将其中的virtual destrutor函数声明为纯虚函数来避免提供一个不适合的纯虚接口，这个纯虚析构函数必须被定义，<br>因为derived classes在析构时会调用base classes的析构函数。<br>　　抽象基类降低了“企图以多态方式对待数组”的机会，让operator=的行为更容易被了解。强迫你明白认知有用之抽象性质的<br>存在。只有在原有的具体类被当做基类使用，才强迫导入一个新的抽象类。<br> 　　当你需要扩展一个程序库而又不能修改代码时，只有少数可行的选择：</p>
<ul>
<li>将你的具体类派生自既存的具体类</li>
<li>试着在程序库的继承体系中找到一个更高层的抽象类</li>
<li>以“你所希望继承的那个程序库类”来实现自己的新类，将程序库类对象作为新类的member</li>
<li><p>写一些non-member functions以供应你希望加入class内部去的机能</p>
<h2 id="如何在同一个程序中结合C-和C"><a href="#如何在同一个程序中结合C-和C" class="headerlink" title="如何在同一个程序中结合C++和C"></a>如何在同一个程序中结合C++和C</h2></li>
</ul>
<ul>
<li>Name Mangling（名称重整）<br>　　Name Mangling是一种程序，通过它C++编译器为程序内的每一个函数编出独一无二的名称，在C中没有重载所以不需要此操作。<br>要抑制Name Mangling需要使用C++的extern “C”的命令，它是一个叙述，说明修饰的部分应该以C语言的方式调用。如果需要同时<br>处理C和C++的使用，可以采用预处理器符号__cplusplus, 这个符号只针对C++才用定义.</li>
</ul>
<p>‘’’<br>//如果在C++环境中我们使用C编译方式</p>
<p>#ifdef __cplusplus<br>extern “C” {</p>
<p>#endif</p>
<p>// code</p>
<p>#ifdef __cplusplus<br>}</p>
<p>#endif</p>
<p>‘’’</p>
<ul>
<li>Statics的初始化<br>　　stait class对象，全局对象，namespace内的对象以及文件范围内的对象，其constructor总在main以前得到执行。<br>而static initialization产生对象的destructors在main调用后。为了使得main是程序起点，很多编译器在main开始出安插<br>一个函数调用的特殊函数完成static initialization.<br>　　尽量使用C++编写main函数，可以调用的命名mian函数进行实际的操作,这样可以保证static的构造和析构被合理调用。<br>‘’’<br>extern “C”<br>int realMain(int argc, char *argv[]);</li>
</ul>
<p>int main(int argc, char *argv[]) {<br>  return realMain(argc, argv);<br>}<br>‘’’</p>
<ul>
<li><p>动态分配内存<br>　　C++使用new和delete， C使用malloc和free进行内存分配，char <em>strdup（const char </em>ps)这个函数的内存分配就会<br>根据不同的调用采取不同的内存分配方式，所以尽量避免调用标准程序库外的函数。</p>
</li>
<li><p>数据结构的兼容性<br>　　在C和C++之间对数据结构做双向交流，应该是安全的，前提是那些结构的定义式在C和C++中都可编译。</p>
</li>
</ul>
<h2 id="让自己习惯于标准C-语言"><a href="#让自己习惯于标准C-语言" class="headerlink" title="让自己习惯于标准C++语言"></a>让自己习惯于标准C++语言</h2><p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深度探索C++对象模型总结]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/17/C++ObjectModel/</url>
      <content type="html"><![CDATA[<p>C++对象模型主要解释为：</p>
<ul>
<li>语言中直接支持面向对象程序设计的部分</li>
<li>对于各种支持的底层实现机制</li>
</ul>
<h1 id="关于对象"><a href="#关于对象" class="headerlink" title="关于对象"></a>关于对象</h1><p>　　C语言中，数据和处理数据的操作时分开声明，而C++采用抽象数据类型进行操作。在C++加上封装并未带来<br>布局成本，在布局以及存取时间上主要的额外负担是由virtual引起的：</p>
<ul>
<li>virtual function 机制：用以支持一个有效率的“执行期绑定”。</li>
<li>virtual base blass : 用以实现“多次出现在继承体系中的base class, 有一个单一而被共享的实例”。</li>
<li>多重继承下的一些额外负担。</li>
</ul>
<a id="more"></a>
<h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><ul>
<li>简单对象模型：members本身不放在objects中，object存储指向member的指针。</li>
<li>表格驱动对象模型：数据与操作分离为两个表格，object存储指向两个表格的指针。</li>
<li>C++对象模型：每一个class产生一堆指向virtual functions的指针，放在virtual table(vtbl)中，每一个class<pre><code>object安插一个vptr指向相关的virtual table，每一个class关联的type_info objects信息。
vptr的设定和重置都由每一个class的constructor, destructor, copy assignment自动完成。
</code></pre></li>
</ul>
<h2 id="关键词所带来的差异"><a href="#关键词所带来的差异" class="headerlink" title="关键词所带来的差异"></a>关键词所带来的差异</h2><p>当一个人感觉到比较好的时候，使用struct取代class，注意struct在C++中的逻辑意义和如何正确使用。</p>
<h2 id="对象的差异"><a href="#对象的差异" class="headerlink" title="对象的差异"></a>对象的差异</h2><p>C++程序设计模型直接支持三种程序设计范式：</p>
<ul>
<li>程序模型</li>
<li>抽象数据类型模型</li>
<li>面向对象模型<br>纯粹以一种范式编写程序，有助于整体行为的良好稳固。</li>
</ul>
<p>C++以下列方式支持多态：</p>
<ul>
<li>经由一组隐式的转化操作，例如把derived class指针转化为一个指向其public bass type的指针</li>
<li>经由virtual function</li>
<li>经由dynamic_cast和typeid运算符<br>多态的主要用途是经由一个共同的接口来影响类型的封装。</li>
</ul>
<p>需要多少内存才能够表示一个class object:</p>
<ul>
<li>其nonstatic data members的总和大小</li>
<li>任何alignment的需要而填补的空间</li>
<li>为了支持virtual 而由内部产生的任何额外负担</li>
</ul>
<hr>
<h1 id="构造函数语意学"><a href="#构造函数语意学" class="headerlink" title="构造函数语意学"></a>构造函数语意学</h1><h2 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h2><p>default constructors在需要的时候被编译器产生出来，但需要注意的是这种需要时编译器方面的而不是程序的需要。<br>一个由于为声明constructor函数而被隐式声明的default constructor将是一个trivial（无用） constructor，在某些情况<br>编译器将会生成nontrivial default constructor.</p>
<ul>
<li><p>带有Defulat Constructor 的Member Class Object：<br>　　在constructor真正被调用生成，编译器在包含这样member的constructor中自动扩张，将member的constructor行为先进行<br>运行，其调用顺序根据member objects在class中的声明顺序决定。</p>
</li>
<li><p>带有Default Constructor 的Base Class<br>　与上面同理，bass class的constructor先进行调用。</p>
</li>
<li><p>带有一个Virtual Function的Class<br>　　class声明或者继承一个virtual Function  /  class派生自一个继承链，其中有一个或多个virtual base classes.<br>一个virtual function table 会被编译器生成，内放virtual function地址。vptr内含vtbl的地址。</p>
</li>
<li><p>带有Virtual Base Class 的 Class</p>
</li>
</ul>
<h2 id="Copy-Constructor的构造操作"><a href="#Copy-Constructor的构造操作" class="headerlink" title="Copy Constructor的构造操作"></a>Copy Constructor的构造操作</h2><p>有三种情况使得一个object的内容作为另一个class object的初值：</p>
<ul>
<li>对一个object做显示的初始化操作</li>
<li>当object被当做参数交给某个函数时</li>
<li>当函数传回一个class object时</li>
</ul>
<p>Default Memberwise Initialization:为定义一个explicit copy constructor时，将object使用递归方式拷贝每个成员。</p>
<p>当class不展现Bitwise Copy Semantics时会合成copy constructor:</p>
<ul>
<li>当class内含一个声明有copy constructorh的member object</li>
<li>继承的base class有一个copy constructor(不论是显示声明还是合成而得)</li>
<li>当class声明一个多多个virtual functions</li>
<li>当class派生于继承链，其中有一个或多个virtual base classes</li>
</ul>
<h2 id="程序转化语意学"><a href="#程序转化语意学" class="headerlink" title="程序转化语意学"></a>程序转化语意学</h2><h2 id="成员们的初始化队伍"><a href="#成员们的初始化队伍" class="headerlink" title="成员们的初始化队伍"></a>成员们的初始化队伍</h2><ul>
<li>初始化一个reference member</li>
<li>初始化一个const member</li>
<li>调用一个base class的constructor,而他拥有一组参数</li>
<li>调用一个member class的constructor， 而它有一组参数<br>initialization list的初始化会被以适当的顺序在constructor之内安插初始化操作，并且在任何explicit user code之前。</li>
</ul>
<hr>
<h1 id="Data-语意学"><a href="#Data-语意学" class="headerlink" title="Data 语意学"></a>Data 语意学</h1><ul>
<li>语言本身所造成的额外负担</li>
<li>编译器对于特殊情况所提供的优化处理</li>
<li>Alignment限制</li>
</ul>
<h2 id="Data-Member的绑定"><a href="#Data-Member的绑定" class="headerlink" title="Data Member的绑定"></a>Data Member的绑定</h2><p>   一个inline函数实体，在整个class声明未被完全看见之前，是不会被评估求值得。</p>
<h2 id="Data-Member的布局"><a href="#Data-Member的布局" class="headerlink" title="Data Member的布局"></a>Data Member的布局</h2><p>　　static data merbers不会被放进class的布局中，members的顺序根据编译器而定，较晚出现的members有较高的地址。</p>
<h2 id="Data-Member的存取"><a href="#Data-Member的存取" class="headerlink" title="Data Member的存取"></a>Data Member的存取</h2><ul>
<li><p>Static Data Members<br>　　static 成员只有一个实例，通过一个指针和对象存取member结果一样。若取一个static data member的地址会得到一个指向<br>其数据类型的指针。name-mangling对其进行独一性的编码。</p>
</li>
<li><p>Nonstatic Data Members<br>　　在成员函数内，data members通过隐式的this指针进行访问，不同data数据的访问是通过对class object地址进行偏移进行访问。<br>Data members的地址在编译期即可获得，当使用继承之类的机制，data members的存取效率会受到影响。</p>
</li>
</ul>
<h2 id="继承与Data-Member"><a href="#继承与Data-Member" class="headerlink" title="继承与Data Member"></a>继承与Data Member</h2><p>　　具体继承并不会增加空间或者存取时间的额外负担。但加上多态机制之后情况就会有所不同，vtbl 和vptr的创建，constructor和destructor对<br>vtbl和vptr的设定和销毁都会带来空间和时间上的负担。<br>　　将vptr放在class object的尾端可以保留base class C struct的对象布局。将vptr放在class object的前端对于在多重继承下，通过指向class<br>members的指针调用virtual function带来一些帮助。</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><h2 id="对象成员的效率"><a href="#对象成员的效率" class="headerlink" title="对象成员的效率"></a>对象成员的效率</h2><h2 id="指向Data-Members的指针"><a href="#指向Data-Members的指针" class="headerlink" title="指向Data Members的指针"></a>指向Data Members的指针</h2><h2 id="取一个nonstatic-data-member的地址，将会得到它在class中的offset"><a href="#取一个nonstatic-data-member的地址，将会得到它在class中的offset" class="headerlink" title=" 　　取一个nonstatic data member的地址，将会得到它在class中的offset"></a> 　　取一个nonstatic data member的地址，将会得到它在class中的offset</h2><h1 id="Function-语意学"><a href="#Function-语意学" class="headerlink" title="Function 语意学"></a>Function 语意学</h1><h2 id="Member的各种调用方式"><a href="#Member的各种调用方式" class="headerlink" title="Member的各种调用方式"></a>Member的各种调用方式</h2><h3 id="Nonstatic-Member-functions"><a href="#Nonstatic-Member-functions" class="headerlink" title="Nonstatic Member functions"></a>Nonstatic Member functions</h3><ul>
<li>改写函数的signature以安插一个额外参数（this)到member function以提供存取管道，使得class object得以将此函数调用。</li>
<li>将每一个“对nonstatic data member”的存取操作改为经由this指针来存取。</li>
<li>将member function通过mangling重新写成一个独一无二的·外部函数。</li>
</ul>
<h3 id="Virtual-Member-functions"><a href="#Virtual-Member-functions" class="headerlink" title="Virtual Member functions"></a>Virtual Member functions</h3><p>  通过虚运行机制进行调用。</p>
<h3 id="Static-Member-functions"><a href="#Static-Member-functions" class="headerlink" title="Static Member functions"></a>Static Member functions</h3><ul>
<li>没有this指针</li>
<li>不能直接存取class中的nonstatic members</li>
<li>不能够被声明为const, volatile， virtual</li>
<li>不需要经由class object才被调用</li>
<li>取一个这样的地址将获得其内存中的地址吗,是一个nonmember函数指针。</li>
</ul>
<h2 id="Virtual-Member-functions-1"><a href="#Virtual-Member-functions-1" class="headerlink" title="Virtual Member functions"></a>Virtual Member functions</h2><p>　　多态以一个public base class的指针或引用寻址出一个derived class object。每个多态class object增加两个members<br>一个字符串或数据表示class的类型和一个指向某个表格的指针（vptr),为了找到函数地址，每一个virtual function被指派一个表格<br>索引值。</p>
<h3 id="多重继承下得Virtual-functions"><a href="#多重继承下得Virtual-functions" class="headerlink" title="多重继承下得Virtual functions"></a>多重继承下得Virtual functions</h3><h2 id="函数的效能"><a href="#函数的效能" class="headerlink" title="函数的效能"></a>函数的效能</h2><h2 id="指向Member-Function的指针"><a href="#指向Member-Function的指针" class="headerlink" title="指向Member Function的指针"></a>指向Member Function的指针</h2><p>　　取一个nonstatic member function的地址得到的时它在内存中真正的地址，这个值不是完全的，需要被绑定到某个class object上才能<br>够通过它调用该函数。</p>
<h2 id="Inline-Functions"><a href="#Inline-Functions" class="headerlink" title="Inline Functions"></a>Inline Functions</h2><ul>
<li>分析函数定义</li>
<li>真正的inline函数扩展操作是在调用的那一点上。</li>
</ul>
<hr>
<h1 id="构造，析构，拷贝语意学"><a href="#构造，析构，拷贝语意学" class="headerlink" title="构造，析构，拷贝语意学"></a>构造，析构，拷贝语意学</h1><p>纯虚函数的存在：可以定义和静态调用一个pure virtual Function, pure virtual function一定需要进行定义，派生类需要进行相关调用。</p>
<h2 id="“无继承”情况下得对象构造"><a href="#“无继承”情况下得对象构造" class="headerlink" title="“无继承”情况下得对象构造"></a>“无继承”情况下得对象构造</h2><p>Plain OI Data  ：struct<br>抽象数据类型    ：ADT（Class)<br>带virtual function类 ：constructor需要再任何base class construtors调用之后，在任何使用者供应的代码之前进行附加vptr初始化。<br>这个时候，copy constructor和copy assignment operator不再是trivial,同样需要对vptr进行操作。</p>
<h2 id="继承体系下得对象构造"><a href="#继承体系下得对象构造" class="headerlink" title="继承体系下得对象构造"></a>继承体系下得对象构造</h2><ul>
<li>虚继承：解决virtual base class的共享性问题</li>
</ul>
<h2 id="vptr初始化语意学"><a href="#vptr初始化语意学" class="headerlink" title="vptr初始化语意学"></a>vptr初始化语意学</h2><ul>
<li>当一个完整的对象被构造起来时</li>
<li>当一个subobject constructor调用了一个virtual function</li>
</ul>
<h2 id="对象复制语意"><a href="#对象复制语意" class="headerlink" title="对象复制语意"></a>对象复制语意</h2><h2 id="对象的效能"><a href="#对象的效能" class="headerlink" title="对象的效能"></a>对象的效能</h2><h2 id="析构语意学"><a href="#析构语意学" class="headerlink" title="析构语意学"></a>析构语意学</h2><ul>
<li>如果object内含一个vptrm那么首先重设相关的virtual table</li>
<li>destructor的函数本体现在被执行</li>
<li>class拥有member class objects,而后者有destructors，那么它们会以声明顺序的相反顺序被调用<br>-</li>
</ul>
<hr>
<h1 id="执行期语意学"><a href="#执行期语意学" class="headerlink" title="执行期语意学"></a>执行期语意学</h1><h2 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h2><p>将object尽可能放置在使用它的那个程序区段附近，这样做可以节省非必要的对象产生操作和摧毁操作。</p>
<ul>
<li>全局对象: 需要静态初始化</li>
<li>局部静态对象: 初始化一次</li>
<li>对象数组：</li>
</ul>
<h2 id="new和delete运算符"><a href="#new和delete运算符" class="headerlink" title="new和delete运算符"></a>new和delete运算符</h2><ul>
<li>通过设当的new运算符函数实例，配置所需的内存</li>
<li>将配置得来的对象设立初值</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Effective C++总结]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/17/EffectiveC++/</url>
      <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦　"></a>视C++为一个语言联邦　</h2><p>当今的C++是个多重范型编程语言(过程形式，面向对象形式，函数形式，泛型形式，元编程形式)，<br>我们应该将C++视为由语言组成的联邦而非单一语言,C++主要分为以下四个次语言：</p>
<ul>
<li>C:<br>C++部分继承了C的语法，这个部分没有模板，重载，继承，异常等语法。</li>
<li>Object-Oriented C++:<br>包含classes(构造析构)， 封装，继承，多态。</li>
<li>Template C++:<br>泛型编程的基础，带来了所谓的Template metaprogramming(TMP)编程。</li>
<li>STL:<br>STL是templater程序库，主要包括容器，迭代器，算法部分。</li>
</ul>
<p>不同的次语言有着不同的规则，在编写程序时要按照你的情况进行策略的转变。<br> <a id="more"></a></p>
<h2 id="尽量以const-enum-inlne替代-define"><a href="#尽量以const-enum-inlne替代-define" class="headerlink" title="尽量以const, enum, inlne替代 #define"></a>尽量以const, enum, inlne替代 #define</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">static_cast</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure>
<h2 id="尽量以const-enum-inlne替代-define-1"><a href="#尽量以const-enum-inlne替代-define-1" class="headerlink" title="尽量以const, enum, inlne替代 #define"></a>尽量以const, enum, inlne替代 #define</h2><p>　　宁可以编译器替换预处理器，因为#define不被视为语言的一部分，使用#define定义的名称没有进入符号表中，所以在追踪这类信息时会带来困扰。<br>预处理器盲目替换宏名称会带来更多的目标码，我们无法使用#define创建一个class专属常量，也不能提供任何封装性,下面的const提供了这些支持。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　如果你的编译环境不支持类内成员初始化，你可以使用所谓的“enum hack”代替，因为一个属于枚举类型的数值可以充当ints被使用。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> &#123;</span> NumTurns = <span class="number">5</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> socres[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　在这里enum hack的行为某些方面比较像#define，因为取一个enum地址也不合法，而取一个const地址则是合法的。enum可以帮助你阻止别人<br>获得一个pointer或reference指向你的某个整数常量，enum hack是template metaprogramming的基础技术。</p>
<p>　　另一个#define误用的地方是定义像函数一样的宏，需要记住宏中所以实参都要加上小括号，这样的形式的宏很容易出现错误。我们可以使用template inline函数去替代它：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">max</span>(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h2><p>　　const允许你指定一个语义约束，而编译器会强制实施这个约束。const在使用时出现在星号左边表示被指物是常量，在右边表示指针本身是常量。<br>STL迭代器以指针为根据塑模处理，所以也可以用const作用于它，其功能类似。const最具威力的用法是面对函数声明时的应用：</p>
<ul>
<li>在一个函数声明式内，const可以和函数返回值，各参数，函数本身产生关联<br>令一个函数返回常量值，可以避免客户端的赋值错误。</li>
</ul>
<p>　　const成员函数确认了此函数可以作用于const对象，使得class接口变得容易理解。同时，使得操作const对象成为可能，以pass by reference-to-const方式传递<br>对象，改善了C++的程序效率。两个成员函数常量性的不同可以成为重载函数，例如可以定义两个版本的operator[], 可以针对不同的情况下进行调用。</p>
<ul>
<li>bitwise constness<br>成员函数不更改对象内任何一个bit，这是C++对常量性的定义。</li>
<li><p>logical constness<br>一个成员函数可以修改它所出来的对象内某些bits，但只有客户端侦测不出的情况下才这样做。</p>
<p>我们可以利用mutable关键字释放not-static成员变量的bitwise constness约束。</p>
<ul>
<li>在const和non-const成员函数中避免重复</li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> TextBlock &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](std::size_t pos) <span class="keyword">const</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">return</span> <span class="built_in">text</span>[pos];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](std::size_t pos)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">return</span> <span class="built_in">text</span>[pos];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免重复，我们令non-const版本调用const版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TextBlock</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) <span class="keyword">const</span></span><br><span class="line">   &#123;</span><br><span class="line">     return text[pos];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">//有两次转型，第一次是为了调用const版本的[]避免递归，第二次是为了移除const</span></span><br><span class="line">     return <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;( static_cast&lt;const TextBlock &amp;)(*this)[pos] );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　需要注意的是，const成员函数承诺不改变对象的逻辑状态，所以使用const版本调用non-const版本是错误的，<br>这样做对象有可能因此被改动，使用了const_cast将（this*)身上的const性质解放掉。</p>
<hr>
<h2 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h2><p>　　读取未初始化的值会导致不明确的行为，在使用对象前先初始化。对于内置类型之外的东西，其初始化责任落在构造函数上。<br>需要注意的是赋值和初始化的区别.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  //<span class="keyword">default</span> construct + copy assignment</span><br><span class="line">  Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">  &#123;</span><br><span class="line">    m_a = a;</span><br><span class="line">    m_b = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> m_a;</span><br><span class="line">   <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　在这个例子是先调用了default构造函数，然后再构造函数内对成员进行了赋值操作。<br>对象的成员变量的初始化动作发生在进入构造函数本体之前。比较好的方式时使用成员初始化列表。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">//copy construct</span><br><span class="line">  <span class="built_in">Test</span>(int a, int b)：<span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b) &#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">private</span>:</span><br><span class="line">   <span class="selector-tag">int</span> <span class="selector-tag">m_a</span>;</span><br><span class="line">   <span class="selector-tag">int</span> <span class="selector-tag">m_b</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　如果成员变量是const或references时，它们一定需要初值而不能被赋值。对于那谢赋值表现得初始化一样好的成员表里，<br>改用它们的赋值操作，并移动到private的某个函数，供所有构造函数调用避免重复代码。<br>C++成员初始化次序总是安装成员声明的顺序，所以避免两个成员变量初始化带有次序性。</p>
<ul>
<li>C++对于定义在不同编译单元内的non-local static 对象的初始化次序无明确的定义<br>non-local对象包括：<br>global对象，定义在namespace作用域内对象<br>在classes内，以及在file作用域内被声明为static的对象。</li>
</ul>
<p>在函数内static对象是local-staic对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> FileSystem &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> numDistks() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Directory &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Directory(params)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = fs.numDistks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当fs在tempDir以前初始化，这才合法，但顺序不是确定的，两者都是global对象，是non-local static对象。</span></span><br><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>　　多个编译单元内的non-local static对象经由模板隐式具现化形成。<br>我们可以使用设计模式中Singleton手法进行处理，C++保证函数内的local static对象会在该函数被调用期间，首次<br>遇上该对象之定义式时被初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> FileSystem &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> numDistks() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSystem &amp; <span class="title">fs</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  staic FileSystem fs;</span><br><span class="line">  return fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Directory &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Directory(params)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = fs().numDistks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Directory &amp; tempDir</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> Directory td;</span><br><span class="line">  return td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="了解C-默默编写并调用哪些函数"><a href="#了解C-默默编写并调用哪些函数" class="headerlink" title="了解C++默默编写并调用哪些函数"></a>了解C++默默编写并调用哪些函数</h2><p>　　一个Empty class并不空，编译器会为它声明一个copy构造函数，一个copy assignment操作符和一个析构函数。<br>如果你没有声明任何构造函数，编译器还会为你声明一个default构造函数，所有这些函数都是public inline。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">Empty</span>() &#123;&#125;</span><br><span class="line">   <span class="keyword">Empty</span>(<span class="keyword">const</span> <span class="keyword">Empty</span> &amp;) &#123;&#125;</span><br><span class="line">  ~<span class="keyword">Empty</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Empty</span> &amp; operator = (<span class="keyword">const</span> <span class="keyword">Empty</span> &amp;rhs) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　在这些函数被需要(调用)时才会被编译器创建处理。这样copy构造函数和copy assignment操作符只是单纯的将来源对象的每一个non-static<br>成员变量拷贝到目标对象。而default构造函数和析构函数主要为编译器调用base classes和non-static成员变量的构造函数和析构函数提供环境。<br>当生将要成的copy assignment合法且有意义时，编译器才会执行生成操作，改变reference对象或者const成员，以及base class将copy assignment<br>定义为private都会导致copy assignment生成失败。</p>
<h2 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>　　在旧C++中，将copy构造函数或者copy assignment操作符声明为private可以阻止人们调用它们。但是member函数和friend函数还是有可能去调用<br>它们，这个时候会产生未定义的连接错误。我们可以将连接器的错误移至编译期，以尽早发现这类错误。具体做法如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   Uncopyable() &#123;&#125;</span><br><span class="line">  ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">   Uncopyable &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">private</span> <span class="title">Uncopyable</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当有(member函数或friend函数)尝试拷贝Test对象的操作发生，需要产生一个copy构造函数和copy assignment函数，这些copy函数会<br>调用基类对应的copy函数，而基类并没有定义这样的copy函数，所以编译器会拒绝这些操作。<br>在C++11中可以使用 = delete函数修饰符声明成员函数为删除的，使得编译器不自动生成。</p>
<h2 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h2><p>　　当derived class对象经由一个base class指针被删除，而该base class带有一个non-virtual析构函数时，其结果未有定义，因为实际执行时对象<br>的derived成分没有被销毁，这造成了资源泄露。任何class只要带有virutal函数都几乎确定应该有一个virtual析构函数，如果不含virtual函数，通常表示<br>它并不意图被作为一个base class。<br>　　classes的设计目的如果不是作为base classes使用，或不是为了具备多态性就不该声明virtual析构函数。即使class完全不带virtual函数，还是可能出现<br>virtual析构函数问题，，当你试图去继承于STL中string,vector,list等不带virtual析构函数的class时就会出现这样的问题。<br>　　abstract classes不能创建对应的对象，当你希望拥有abstract classes而又没有合适的pure virtual函数时，可以将virtual函数声明为pure。这里有个要<br>注意的地方是：你需要为pure virtual析构函数提供一个定义，因为其派生类的析构会自动调用基类的析构函数，所以需要有一个定义。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     virtual ~AWOV() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要提供一份定义</span></span><br><span class="line">AWOV::~AWOV(） &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h2><p>　　C++并不禁止析构函数抛出异常，当这样做往往会造成资源的泄露或者多次抛出异常导致不明确的行为。<br>为了避免这个问题，往往采取以下方法：<br>1.如果调用抛出异常时就结束程序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test::~Test()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.close();  &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">      <span class="comment">//调用失败时记录</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">abort</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.吞下因调用函数而发生的异常<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Test</span>::~<span class="keyword">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line">    try &#123; <span class="keyword">db</span>.<span class="keyword">close</span>();  &#125;</span><br><span class="line">    catch(...) &#123;</span><br><span class="line">      <span class="comment">//调用失败时记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两种方法都无法对“导致函数调用抛出异常”的情况做出反应。我们可以重新设计接口，使得客户有<br>机会对可能出现的问题作出反应，通过提供一个普通函数而非在析构函数中执行来对抛出的异常进行处理。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void <span class="keyword">Test</span>::<span class="keyword">close</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">db</span>.<span class="keyword">close</span>();</span><br><span class="line">  closed = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Test</span>::~<span class="keyword">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      <span class="keyword">db</span>.<span class="keyword">close</span>();</span><br><span class="line">    &#125; catch(...) &#123;</span><br><span class="line">      <span class="comment">//调用失败时记录</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h2><p>　　在base构造期间，virtual函数不是virtual函数，base class构造期间virtual函数不会下降到derived classed阶层，因为此时<br>的派生类部分还为进行构造。这个时候的对象类型是base class而不是derived class。除此之外，使用运行期类型信息(typeid或dynamic_cast)<br>也是同样的结果。<br>　　同样道理，一旦derived class析构函数开始执行，对象内的derived class成员变量就呈现未定义值，进行base class析构函数后对象就<br>成为一个base class对象，这个时候virtual函数并不起到想要的作用。<br>　　确定你的析构函数和构造函数都没有（在对象被创建和被销毁期间）调用virtual 函数，而它们调用的所有函数也都服从同一约束。
　</p>
<h2 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator = 返回一个reference to this"></a>令operator = 返回一个reference to this</h2><p>　　为了能够对对象进行连续赋值，赋值操作符应该返回一个reference指向操作符的左侧参数，这只是个协议并没有强制性。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Test&amp; <span class="keyword">operator</span> = （const Test &amp;rhs)   <span class="comment">//同样适用于+=，-=， *=等等赋值相关运算</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="赋值对象时勿忘其每一个成分"><a href="#赋值对象时勿忘其每一个成分" class="headerlink" title="赋值对象时勿忘其每一个成分"></a>赋值对象时勿忘其每一个成分</h2><p>　　当你自己定义class的copy构造函数和copy assignment操作符时，编译器不会生成将所有成员进行拷贝的默认copy操作函数。<br>所以如果你为class添加一个新成员变量，你必须同时修改对应的copy函数。除此之外，当你继承于这样的base class时，要注意在<br>派生类中的copy函数调用基类copy函数对基类成员变量进行copy操作，如果没有调用的话编译器对基类的copy可能是采取default构造函数对<br>成员变量进行缺省的初始化动作。</p>
<p>当你编写一个copy函数时，请确保：</p>
<ul>
<li>复制所有local成员变量</li>
<li>调用所有base calsses内的适当的copying函数<br>记住不要尝试以copy构造函数去调用copy assignment，反之亦然。如果要避免代码重复的话，应该讲共同机能放进新的成员函数中，<br>这个函数通常为private且命名为init，然后两个copy函数共同调用这个init函数。</li>
</ul>
<hr>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>当你使用了动态分配的资源，将来必须还给系统。</p>
<h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test *pInv = createTest();</span><br><span class="line">  ...   <span class="comment">//在这里return或者抛出异常时会造成资源泄露</span></span><br><span class="line">  <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对上面的资源释放的问题，我们可以使用对象自动运行析构函数机制来确保资源释放。<br>以对象管理资源主要有一下两个关键思想：<br>1.获得资源后立刻放进管理对象中,资源获取的时机便是初始化时机(RAII)。<br>2.管理对象运用析构函数确保资源被释放。</p>
<p>auto_ptr的工作原理基本与上述思想一致，auto_ptr管理的资源不允许其他auto_ptr再次指向。<br>因此我们可以使用引用计数型智慧指针（RCSP）shared_ptr进行资源管理，shared_ptr保存有对象指向<br>资源，当引用计数为0时自动删除该资源，需要注意的一点是RCSPs无法打破环状引用。</p>
<h2 id="在资源管理类中小心copying行为"><a href="#在资源管理类中小心copying行为" class="headerlink" title="在资源管理类中小心copying行为"></a>在资源管理类中小心copying行为</h2><p>资源在构造期间获得，在析构期间释放。<br>当一个RAII对象被复制时:<br>1.禁止复制，将copying函数声明为private实现。<br>2.对底层资源祭出“引用计数法”, shared_ptr允许指定”删除器”来扩展使用方法。<br>3.复制底部资源（deep copying)，复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。<br>4.转移底部资源的所有权（auto_ptr).<br>普遍而常见的RAII class copying行为是：抑制copying,施行引用计数法，不过其他行为也都可能被实现。</p>
<h2 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h2><p>APIs往往要求访问原始资源，所以每一个RAII class应该提供一个取得其所管理之资源的方法。<br>在shared_ptr中get()就提供了返回指针内部原始指针的访问，在这里是进行了显示的转换。<br>对原始资源的访问可能经由显示转换或隐式转换，一般而言显示转换比较安全，但隐式转换对客户比较方便。</p>
<h2 id="成对使用new和delete时要采取相同形式"><a href="#成对使用new和delete时要采取相同形式" class="headerlink" title="成对使用new和delete时要采取相同形式"></a>成对使用new和delete时要采取相同形式</h2><p>如果你在new表达式使用[]，必须在相应的delete表达式中也使用[]，如果在new中不使用，那么在delete也不应该使用。<br>delete需要你告诉它被删除的内存有多少对象，当使用typedef对数组形式进行简化时需要注意delete的行为。<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> Address[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">string</span> *pstr = <span class="keyword">new</span> Address;</span><br><span class="line"><span class="keyword">delete</span> [] pstr; <span class="comment">//使用delete pstr是错误的</span></span><br></pre></td></tr></table></figure></p>
<h2 id="以独立语句将newed对象置入智能指针"><a href="#以独立语句将newed对象置入智能指针" class="headerlink" title="以独立语句将newed对象置入智能指针"></a>以独立语句将newed对象置入智能指针</h2><p>以独立语句将newed对象存储于智能指针，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="keyword">shared</span><span class="number">_p</span>tr&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br><span class="line"><span class="comment">//这里编译器对应参数的操作执行顺序没有严格的规定，当new Widget -&gt; priority() -&gt; shared_ptr构造</span></span><br><span class="line"><span class="comment">//priority抛出异常时资源泄露</span></span><br><span class="line"><span class="comment">//所以应该分离语句</span></span><br><span class="line"><span class="keyword">shared</span><span class="number">_p</span>tr&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">processWidget(pw, priority);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h2><p>　　如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码就不应该通过编译，设计良好的接口必须考虑客户可能做出什么样的错误。<br>许多客户端的错误可以通过导入新类型而得到解决。让types容易被正确使用，不容易被误用，尽量使得你的types行为与内置types一致。<br>阻止误用的办法包括建立新类型，限制类型上的操作，束缚对象值，消除客户的资源管理责任。<br>shared_ptr支持定制型删除器，可用来防范DLL问题：对象在动态链接程序库被new创建，却在另一个DLL内被delete。</p>
<h2 id="设计class犹如设计type"><a href="#设计class犹如设计type" class="headerlink" title="设计class犹如设计type"></a>设计class犹如设计type</h2><p>当你定义一个新class，也就定义了一个新type，好的types有自然的语法，直观的语义，以及一或多个高效实现品。</p>
<ul>
<li>新type的对象应该如何被创建和销毁</li>
<li>对象的初始化和对象的赋值该有什么样的区别</li>
<li>什么是新type的合法值</li>
<li>你的新type需要配合某个继承图系</li>
<li>你的新type需要什么样的转换</li>
<li>什么样的操作符合函数对此新type而言是合理的</li>
<li>什么样的标准函数应该驳回</li>
<li>什么是新type的未声明接口</li>
<li>你的新type有多么一般化</li>
</ul>
<h2 id="宁可pass-by-reference-to-const替换pass-by-value"><a href="#宁可pass-by-reference-to-const替换pass-by-value" class="headerlink" title="宁可pass-by-reference-to-const替换pass-by-value"></a>宁可pass-by-reference-to-const替换pass-by-value</h2><p>　　pass-by-value需要创建副本，带来的事对象的构造成本，在函数传递时实参会调用对象的copy构造函数进行复制。而采用pass-by-reference-to-const<br>则可以避免构造函数或析构函数的调用，除此之外by reference方式传递参数也可以避免对象切割问题（当derived class对象以by value方式传递到一个base<br>class对象上，derived 部分会被抛弃）。<br>　　以上规则并不适用于内置类型，STL的迭代器和函数对象，对他们来说，pass-by-value往往比较适合。</p>
<h2 id="必须返回对象时，别妄想返回其reference"><a href="#必须返回对象时，别妄想返回其reference" class="headerlink" title="必须返回对象时，别妄想返回其reference"></a>必须返回对象时，别妄想返回其reference</h2><p>　　绝不要返回pointer或reference指向某个local stack对象，因为函数调用结束后local对象会被销毁。<br>也不要返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有<br>可能同时需要多个这样的对象。</p>
<h2 id="将成员变量声明为private"><a href="#将成员变量声明为private" class="headerlink" title="将成员变量声明为private"></a>将成员变量声明为private</h2><p>将成员变量声明为private，可赋予客户范文数据的一致性，可细微划分访问控制，许诺约束条件获得保证，并提高class作者以充分的实现弹性。<br>protected并比public更具封装性，封装性与其内容改变时可能造成的代码破坏量成反比。</p>
<h2 id="宁以non-member-non-friend替换member函数"><a href="#宁以non-member-non-friend替换member函数" class="headerlink" title="宁以non-member,non-friend替换member函数"></a>宁以non-member,non-friend替换member函数</h2><p>宁以non-member,non-friend替换member函数，这样可以增加封装性，包裹弹性和机能扩充性。</p>
<h2 id="若所有参数皆需类型转换，请为此采用non-member函数"><a href="#若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数皆需类型转换，请为此采用non-member函数"></a>若所有参数皆需类型转换，请为此采用non-member函数</h2><h2 id="考虑写出一个不抛出异常的swap函数"><a href="#考虑写出一个不抛出异常的swap函数" class="headerlink" title="考虑写出一个不抛出异常的swap函数"></a>考虑写出一个不抛出异常的swap函数</h2><hr>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="尽可能延后变量定义式的出现时间"><a href="#尽可能延后变量定义式的出现时间" class="headerlink" title="尽可能延后变量定义式的出现时间"></a>尽可能延后变量定义式的出现时间</h2><p>因为异常的抛出和程序错误可能会使早些定义好的变量没有析构，造成资源泄露。</p>
<h2 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h2><p>const_cast<t>();     //常量性移除<br>dynamic_cast<t>();   //安全向下转型<br>reinterpret_cast<t>(); //低级转型<br>static_cast<t>();    //隐式转型</t></t></t></t></p>
<h2 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h2><p>避免dangling handles</p>
<h2 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h2><p>不泄露任何资源<br>不允许数据败坏</p>
<h2 id="彻底了解inlining的里里外外"><a href="#彻底了解inlining的里里外外" class="headerlink" title="彻底了解inlining的里里外外"></a>彻底了解inlining的里里外外</h2><p>　　对函数调用使用函数本体进行替换，增加目标码，导致额外的换页行为，降低指令高速缓存装置的击中率。<br>inline只是对编译器的申请，而不是强制命令，一般放在头文件中。编译器会拒绝过于复杂（带有循环或递归）<br>的函数inline，一个函数是否真正inline，取决于你的建置环境，主要取决于编译器。<br>编译器不对通过函数指针而进行的调用实施inlining,当程序需要取某个inline函数的地址时也不会inline.</p>
<h2 id="将文件间的编译依存关系降至最低"><a href="#将文件间的编译依存关系降至最低" class="headerlink" title="将文件间的编译依存关系降至最低"></a>将文件间的编译依存关系降至最低</h2><p>　　使用object references或object pointer完成任务，不用objects.<br>尽量以class声明式替换class定义式。</p>
<p>1.pimpl idiom</p>
<h2 id="2-interface-class"><a href="#2-interface-class" class="headerlink" title="2.interface class"></a>2.interface class</h2><h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="确定你的public继承塑模出is-a关系"><a href="#确定你的public继承塑模出is-a关系" class="headerlink" title="确定你的public继承塑模出is-a关系"></a>确定你的public继承塑模出is-a关系</h2><p>　　能够施加于base class对象身上的每件事情，都可以施加于derived class对象上；每一个derived class也都是一个base class.<br>企鹅与鸟，矩形和正方形都是错误的public继承。</p>
<h2 id="避免遮掩继承而来的名称"><a href="#避免遮掩继承而来的名称" class="headerlink" title="避免遮掩继承而来的名称"></a>避免遮掩继承而来的名称</h2><p>　　derived class作用域被嵌套在base class作用域内，所以derived classes内的名称会遮掩base classes内的名称。我们可以通过<br>使用using声明式或转交函数（在devied class function中调用base版本进行实现）避免。</p>
<h2 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h2><ul>
<li>声明一个pure virtual函数的目的是为了让dericed classed只继承函数接口。</li>
<li>声明impure virtual函数的目的是为了让derived classes继承该函数的接口和缺省实现。</li>
<li>声明non-virtual函数的目的是为了令derived classes继承函数的接口以及一份强制性实现。</li>
</ul>
<h2 id="考虑virtual函数以外的其他选择"><a href="#考虑virtual函数以外的其他选择" class="headerlink" title="考虑virtual函数以外的其他选择"></a>考虑virtual函数以外的其他选择</h2><ul>
<li>借由Non-Virtual Interface手法实现Template Method模式</li>
<li>借由Function Pointers实现Strategy模式</li>
<li>借由tr1::function完成Strategy模式</li>
<li>古典Strategy模式</li>
</ul>
<h2 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h2><p>　　重新定义继承而来的non-virtual破坏了继承的is-a关系，不变性凌驾特异性。</p>
<h2 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h2><p>　　缺省参数值是静态绑定，当你在调用一个定义于derived class内的virtual函数同时却使用base class为它所指定的<br>缺省参数值。</p>
<h2 id="通过复合塑模出has-a或“根据某物实现出”"><a href="#通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或“根据某物实现出”　　"></a>通过复合塑模出has-a或“根据某物实现出”　　</h2><p>　　在应用域复合意味着has-a(有一个)，程序中的对象其实相当于你塑造的世界中的某些事物（人，汽车）。<br>在实现域复合意味着is-implemented-in-terms-of(根据某物实现出)，实现细节上的人工制品（缓冲去，互斥器，查找树）</p>
<h2 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h2><p>　　private继承意味is-implemented-in-terms-of, 他通常比复合级别低。private继承可以造成空白基类最优化EBO。<br>private继承不会讲一个derived class对象转换为一个base class对象。由private继承而来的所有成员会变成private属性。<br>private继承是一种实现技术，意味只有部分被继承，接口部分应略去。</p>
<h2 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h2><p>　　多重继承比单一继承复杂，可能导致新的歧义性以及对virtual继承的需要。而virtual继承会增加大小，速度，初始化和赋值复杂度的成本。<br>多重继承适用于涉及“public 继承某个interface class”和”private”继承某个协助实现的class”的两相组合。</p>
<hr>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h2><p>　　classes和templates都支持接口和多态，对classes而言接口是显式的，以函数签名为中心，多态则是通过virtual函数发生于运行期。<br>对与templeate参数而言，接口是隐式的，通过template具现化和函数重载解析发生于编译期。</p>
<h2 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h2><p>　　声明template参数时，前缀关键词class和typename可以互换。<br>请使用关键词typename标识嵌套从属类型名称,但不得在base class lists或member initialization list内以它作为base class修饰符。</p>
<h2 id="学习处理模板化基类内的名称"><a href="#学习处理模板化基类内的名称" class="headerlink" title="学习处理模板化基类内的名称"></a>学习处理模板化基类内的名称</h2><p>　　可在derived class templates内通过this-&gt;指涉base class templates内的成员名称，或借由一个明白写出的base class资格修饰符完成。</p>
<h2 id="将与参数无关的代码抽离templates"><a href="#将与参数无关的代码抽离templates" class="headerlink" title="将与参数无关的代码抽离templates"></a>将与参数无关的代码抽离templates</h2><p>　　Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。<br>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或class成员变量替换template参数。<br>因类型参数而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述的具现类型共享实现码。</p>
<h2 id="运用成员函数模板接受所有兼容类型"><a href="#运用成员函数模板接受所有兼容类型" class="headerlink" title="运用成员函数模板接受所有兼容类型"></a>运用成员函数模板接受所有兼容类型</h2><p> 　请使用member function templates生成可接受所有兼容类型的函数。<br> 如果你声明member templates用于”泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment<br> 操作符。</p>
<h2 id="需要类型转换时请为模板定义非成员函数"><a href="#需要类型转换时请为模板定义非成员函数" class="headerlink" title="需要类型转换时请为模板定义非成员函数"></a>需要类型转换时请为模板定义非成员函数</h2><p>　　当我们编写一个class template， 而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为<br>“class template内部的friend函数”。</p>
<h2 id="请使用traits-classes表现类型信息"><a href="#请使用traits-classes表现类型信息" class="headerlink" title="请使用traits classes表现类型信息"></a>请使用traits classes表现类型信息</h2><p>　　Traits classes使得“类型相关信息”在编译期可用，它们以templates和templeates特化完成实现。<br>整合重载技术后，traits classes有可能在编译期对类型执行if_else测试。</p>
<h2 id="认识template元编程"><a href="#认识template元编程" class="headerlink" title="认识template元编程"></a>认识template元编程</h2><p>　　模板元编程可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。<br>TMP可被用来生成“基于政策选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</p>
<hr>
<h1 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h1><h2 id="了解new-handler的行为"><a href="#了解new-handler的行为" class="headerlink" title="了解new-handler的行为"></a>了解new-handler的行为</h2><p>　　当operator new抛出异常以反映一个未获满足的内存需求之前，会先调用一个客户指定的错误处理函数，称为<br>new-handler.<br>一个良好的new-handler必须做到以下几点：</p>
<ul>
<li>让更多内存可被使用</li>
<li>安装另一个new-handler</li>
<li>卸载new-handler</li>
<li>抛出bad_alloc</li>
<li>不返回<br>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配，后继的构造函数调用还是可能抛出异常。</li>
</ul>
<h2 id="了解new和delete的合理替换时机"><a href="#了解new和delete的合理替换时机" class="headerlink" title="了解new和delete的合理替换时机"></a>了解new和delete的合理替换时机</h2><ul>
<li>为了检测运用错误</li>
<li>为了收集动态分配内存之使用统计信息。</li>
<li>为了增加分配和归还的速度</li>
<li>为了降低缺省内存管理器带来的空间额外开销</li>
<li>为了补偿缺省分配器中的非最佳齐位</li>
<li>为了将相关对象成簇集中</li>
<li>为了获得非传统的行为</li>
</ul>
<h2 id="编写new和delete时需固守常规"><a href="#编写new和delete时需固守常规" class="headerlink" title="编写new和delete时需固守常规"></a>编写new和delete时需固守常规</h2><p>　　operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也<br>应该有能力处理0bytes申请，Class 专属版本则还应该处理“比正确大小更大的错误申请”。<br>　　operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的错误申请”。</p>
<h2 id="写了plac-ement-new也要写placement-delete"><a href="#写了plac-ement-new也要写placement-delete" class="headerlink" title="写了plac ement new也要写placement delete"></a>写了plac ement new也要写placement delete</h2><p>　　如果operator new接受的参数除了一定会有的那个size_t之外还有其他，这个是一个placement new.</p>
<hr>
<h1 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h1><h2 id="不要轻忽编译器的警告"><a href="#不要轻忽编译器的警告" class="headerlink" title="不要轻忽编译器的警告"></a>不要轻忽编译器的警告</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">A</span>&#123;</span><br><span class="line">  <span class="attribute">public</span>:</span><br><span class="line">    virtual void <span class="built_in">f</span>() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">B</span> : <span class="selector-tag">public</span> <span class="selector-tag">A</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">  virtual void <span class="built_in">f</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子中，Class B本来的意图是要重新定义A中f(),但由于B中f()为添加const标志，所以编译器提供的是<br>覆盖警告，这时你要确保你了解它表达的真正意图。</p>
<p>严肃对待编译器发出的警告信息，努力在你的编译器的最高警告级别下真去无任何警告的荣誉。<br>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦依植到另一个<br>编译器上，你原本依赖的警告信息有可能消失。</p>
<h2 id="让自己熟悉包括TR1以内的标准程序库"><a href="#让自己熟悉包括TR1以内的标准程序库" class="headerlink" title="让自己熟悉包括TR1以内的标准程序库"></a>让自己熟悉包括TR1以内的标准程序库</h2><p>在这些里面很多特性已经成为C++11的标准</p>
<ul>
<li>智能指针shared_ptr, weak_ptr</li>
<li>函数对象function</li>
<li>Hash tables</li>
<li>正则表达式</li>
<li>Tuples</li>
<li>array</li>
<li>Type traits<br>Boost程序库提供很多即将成为标准的组件。</li>
</ul>
<h2 id="让自己熟悉Boost"><a href="#让自己熟悉Boost" class="headerlink" title="让自己熟悉Boost"></a>让自己熟悉Boost</h2><p>Boost主要分为以下几个组件：</p>
<ul>
<li>字符串和文本处理</li>
<li>容器</li>
<li>函数对象和高级编程</li>
<li>泛型编程</li>
<li>模板元编程</li>
<li>数学和数值</li>
<li>正确性与测试</li>
<li>数据结构</li>
<li>语言间的支持</li>
<li>内存</li>
<li>杂项</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[敏捷软件开发：原则 ，模式和实践]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/17/AgileSoftwareDevelopment/</url>
      <content type="html"><![CDATA[<h1 id="敏捷设计"><a href="#敏捷设计" class="headerlink" title="敏捷设计"></a>敏捷设计</h1><hr>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cocos2dx-AndroidStudio]]></title>
      <url>https://byhj.github.io/blog/blog/2015/12/16/Cocos2dx-AndroidStudio/</url>
      <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>   本文主要简单介绍Cocos2dx中怎么使用AndroidStudio开发.</p>
<h1 id="2-测试环境"><a href="#2-测试环境" class="headerlink" title="2.测试环境"></a>2.测试环境</h1><p>Windows10<br>Cocos2dx3.9<br>AndroidStudio1.3.2</p>
 <a id="more"></a>
<h1 id="3-内容"><a href="#3-内容" class="headerlink" title="3.内容"></a>3.内容</h1><p>   Cocos2dx的环境配置安装官网上说的进行，下载所需要的sdk，在Cocos2dx 的build文件夹中用VS2015打开解决方案，编译链接程序。<br>    编译成功后使用Cocos控制台命令创建一个HelloWorld工程</p>
<pre><code>cocos new HellWorld -p com.byhj -l cpp -d D:/Cocos2dX
</code></pre><p>  在D盘的Cocos2dx文件夹中可以看见新生成的HelloWorld的cocos2dx工程，里面有着多个平台开发的项目选择，一般我们使用VS编写调试工程，最后移植到所需要的平台。<br>     接着就是使用AndroidStudio测试的关键部分，因为AndroidStudio使用gradle构建系统，所以具体NDK的使用跟Eclipse有所区别，而且在AndroisStudio1.3以后，使用gradle-experimental支持NDK开发。在新生成HelloWorld工程根目录打开cmd，输入下面命令：</p>
<pre><code>cocos run/compile -p android --android-studio      
</code></pre><p> 这个命令使用NDK将C++文件生成Android平台下的so库文件，通过JNI被Java程序调用，具体细节暂时不用去探究，当NDK编译完成后，使用AndroidStudio导入HelloWorld工程里面的proj.android-studio工程。  编译链接，正常情况下可以使用手机设备或者安卓模拟器看到HelloWorld的测试场景。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Movie]]></title>
      <url>https://byhj.github.io/blog/blog/2015/10/06/Movie/</url>
      <content type="html"><![CDATA[<h1 id="Movie"><a href="#Movie" class="headerlink" title="Movie"></a>Movie</h1><h2 id="Science-Fiction"><a href="#Science-Fiction" class="headerlink" title="Science Fiction"></a>Science Fiction</h2><p>黑客帝国<br>大鱼<br>盗梦空间<br> 深空失忆<br> 忍者神龟<br> 星际穿越<br> 第九区</p>
 <a id="more"></a>
<p> 我是传奇<br> 回到未来<br> 博物馆奇妙夜<br> 独立日<br> 月球<br> 爱丽丝梦游仙境<br> 时间规划局<br> 大白鲨<br> 致命ID<br> 禁闭岛<br> 阿凡达<br> 哈利波特<br> 机器管家</p>
<hr>
<h2 id="Love-story"><a href="#Love-story" class="headerlink" title="Love story"></a>Love story</h2><p>怦然心动<br>泰坦尼克号<br> 恋恋笔记本<br> 暖暖内含光<br> 八月迷情<br> 明亮的星<br> 初恋这件小事<br> 两小无猜<br> 真爱至上<br>  曾经<br>  天使爱美丽<br>  闻香识女人<br>  返老还童<br>  平民窟的百万富翁<br>  傲慢与偏见<br> 朗诵者<br> 和莎莫得500天<br> 成为简·奥斯汀<br> 你眼中的世界<br> 时间旅行者的妻子<br> 午夜巴塞罗那<br> 人鬼情未了<br> 钢琴课<br> 纯真年代</p>
<hr>
<h2 id="Feature-film"><a href="#Feature-film" class="headerlink" title="Feature film"></a>Feature film</h2><p>肖申克的救赎<br>这个杀手不太冷<br>阿甘正传<br>三傻大闹宝莱坞<br>忠犬八公的故事<br>教父<br>当幸福来敲门<br>楚门的世界<br>指环王<br>触不可及<br>窃听风暴<br>蝙蝠侠：黑暗骑士<br>美丽心灵<br>七宗罪<br>心灵捕手<br>死亡诗社<br> 幸福终点站<br> 雨人<br> 记忆碎片<br> 我是山姆<br> 黑天鹅<br> 荒野生存<br> 战争之王<br> 叫我第一名<br> 遗愿清单<br> 国王的演讲<br> 莫扎特传<br> 速度与激情<br> 圣诞小屋<br> 超凡蜘蛛侠</p>
<h2 id="谍影重重1-3"><a href="#谍影重重1-3" class="headerlink" title=" 谍影重重1-3"></a> 谍影重重1-3</h2><h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><p>海上钢琴师<br>钢琴家<br>放牛班的春天<br>她比烟花寂寞<br>舞出我人生</p>
<hr>
<h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><p>千与千寻<br>机器人总动员<br>幽灵公主<br>萤火虫之墓<br>风之谷<br>秒速5厘米<br>驯龙高手<br>天空之城<br>龙猫<br>哈尔的移动城堡<br>飞屋环游记<br>超能陆战队<br>夏日大作战<br>云之彼岸：约定的地方<br>侧耳倾听<br>冰雪奇缘</p>
<hr>
<h1 id="Documentary"><a href="#Documentary" class="headerlink" title="Documentary"></a>Documentary</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-Tutorials]]></title>
      <url>https://byhj.github.io/blog/blog/2015/09/21/OpenGL-Tutorials/</url>
      <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="OpenGL3-0"><a href="#OpenGL3-0" class="headerlink" title="OpenGL3.0+"></a>OpenGL3.0+</h2><p>我个人认为比较好的教程，可优先学习：</p>
<ul>
<li><a href="http://www.learnopengl.com/" target="_blank" rel="external">Learning OpenGL</a></li>
<li><a href="http://www.opengl-tutorial.org/" target="_blank" rel="external">opengl-tutorial</a></li>
<li><a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">OpenGL-Step-by-Step</a></li>
<li><a href="https://tutorialsplay.com/opengl/" target="_blank" rel="external">tutorialsplay</a></li>
<li><a href="http://antongerdelan.net/opengl/index.html" target="_blank" rel="external">antongerdelan</a></li>
<li><a href="http://www.mbsoftworks.sk/index.php?page=tutorials&amp;series=1" target="_blank" rel="external">mbsoftworks</a></li>
</ul>
<a id="more"></a>
<p>OpenGL官网推荐的：</p>
<ul>
<li><a href="https://openclassrooms.com/courses/developpez-vos-applications-3d-avec-opengl-3-3" target="_blank" rel="external">Develop with OpenGL 3.1 from scratch (Français)</a></li>
<li><a href="http://alfonse.bitbucket.org/oldtut/index.html" target="_blank" rel="external">Learning Modern 3D Graphics Programming Through OpenGL</a></li>
<li><a href="http://openglbook.com/" target="_blank" rel="external">http://openglbook.com/</a></li>
<li><a href="http://www.spieleprogrammierung.net/" target="_blank" rel="external">Spiele Programmierung Windows OpenGL 3 Tutorials And Articles</a></li>
<li><a href="http://www.swiftless.com/opengl4tuts.html" target="_blank" rel="external">Swiftless OpenGL 4 Tutorials</a></li>
<li><a href="http://www.tomdalling.com/blog/category/modern-opengl/" target="_blank" rel="external">Modern OpenGL Tom Dalling</a></li>
</ul>
<h2 id="Pre-OpenGL3-0"><a href="#Pre-OpenGL3-0" class="headerlink" title="Pre-OpenGL3.0"></a>Pre-OpenGL3.0</h2><p>旧渲染管线看得不多，比较好的是Nehe和lighthouse3d,其它没怎么了解。</p>
<ul>
<li><a href="http://nehe.gamedev.net/" target="_blank" rel="external">Nehe</a></li>
<li><a href="http://www.lighthouse3d.com/" target="_blank" rel="external">lightHouse3d</a></li>
<li><a href="http://lazyfoo.net/tutorials/OpenGL/index.php" target="_blank" rel="external">Lazy Foo’s OpenGL Tutorial</a></li>
<li><a href="http://www.swiftless.com/opengltuts.html" target="_blank" rel="external">Swiftless Tutorials OpenGL 1 &amp; 2</a></li>
<li><a href="http://www.songho.ca/opengl/index.html" target="_blank" rel="external">SongHo OpenGL tutorials</a></li>
<li><a href="http://www.marekknows.com/" target="_blank" rel="external">MarekKnows.com</a></li>
</ul>
<hr>
<h1 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h1><p>OpenGL最经典三本书</p>
<ul>
<li>红皮书: OpenGL Programming Guide</li>
<li>蓝皮书: OpenGL SuperBible</li>
<li>橙皮书: OpenGL Shading Language</li>
</ul>
<p>还有一本值得推荐的</p>
<ul>
<li>OpenGL Insights</li>
</ul>
<p>再想深入的话可以看OpenGL的官方说明文档</p>
<hr>
<h1 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h1><p>GLUT(太老了，不建议使用，freeglut完全可以替代)<br>Freeglut<br>GLFW<br>SDL<br>QtOpenGL</p>
<hr>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>红宝书和蓝宝书的Code可以看看，还有教程的配套Code.<br>G-Truc的Code Sample,例子简单但很全。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-BufferObject]]></title>
      <url>https://byhj.github.io/blog/blog/2015/09/20/OpenGL-BufferObject/</url>
      <content type="html"><![CDATA[<h1 id="Introdution"><a href="#Introdution" class="headerlink" title="Introdution"></a>Introdution</h1><p>Buffer Objects是存储OpenGL Context(GPU)分配的一组非格式化内存的OpenGL Objects. 这些内存能够用来存储顶点数据，图像或者帧缓存返回的像素数据和其它数据。</p>
<h1 id="Creation"><a href="#Creation" class="headerlink" title="Creation"></a>Creation</h1><p>Buffer Objects是OpenGL Objects,所以它们遵循所有OpenGL Objects的规定。你能使用glGenBuffersc创建Buffer Objects, 使用glDeleteBuffers删除它们。这些都是大多数OpenGL Object使用的标准生成和创建Objects的模式。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glBindBuffer(<span class="class"><span class="keyword">enum</span> <span class="title">target</span>, <span class="title">uint</span> <span class="title">bufferName</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>Buffer Objects存储的是任意大小的线性内存数组，这些内存在使用前需要被分配，有两种为Buffer Objects 分配内存的方法：可变或者不可变。为buffer分配不可变内存会改变你跟Buffer Object交互的方式。</p>
<a id="more"></a>
<h2 id="Immutable-Storage"><a href="#Immutable-Storage" class="headerlink" title="Immutable Storage"></a>Immutable Storage</h2><p>Buffer Objects被分配为不可变方式时，你不能为这个Buffer重新分配内存。使用explicit invalidation<br>command 或者mapping the buffer.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBufferStorage</span><span class="params">(GLenum <span class="keyword">target</span>, GLsizeiptr size, <span class="keyword">const</span> GLvoid * data, GLbitfield flags)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Immutable-access-methods"><a href="#Immutable-access-methods" class="headerlink" title="Immutable access methods"></a>Immutable access methods</h3><ul>
<li><p>Writing to the buffer with any rendering pipeline process. These include Transform Feedback, Image Load Store, Atomic Counter, and Shader Storage Buffer Object. Basically, anything that is part of the rendering pipeline that can write to a buffer will always work.</p>
</li>
<li><p>Clearing the buffer. Because this only transfers a few bytes of data, it is not considered “client-side” modification.</p>
</li>
<li><p>Copying the buffer. This copies from one buffer to another, so it all happens “server-side”.<br>Invalidating the buffer. This only wipes out the contents of the buffer, so it is considered “server-side”.</p>
</li>
<li><p>Asynchronous pixel transfers into the buffer. This sets the data in a buffer, but only through pure-OpenGL mechanisms.</p>
</li>
<li><p>Using glGetBufferSubData? to read a part of the buffer back to the CPU. This is not a “server-side” operation, but it’s always available regardless.</p>
</li>
</ul>
<hr>
<h1 id="Data-Specification"><a href="#Data-Specification" class="headerlink" title="Data Specification"></a>Data Specification</h1><p>因为glBufferData在分配内存空间同时更新数据，所以并不适合更新那些已经分配内存的数据（这对于immutable storage buffers是不可能的）</p>
<p>我们可以使用下面的函数去更新buffer部分的数据：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glBufferSubData(<span class="class"><span class="keyword">enum</span> <span class="title">target</span>, <span class="title">intptr</span> <span class="title">offset</span>, <span class="title">sizeiptr</span> <span class="title">size</span>,  <span class="title">const</span> <span class="title">void</span> *<span class="title">data</span>)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Clearing"><a href="#Clearing" class="headerlink" title="Clearing"></a>Clearing</h2><p>Buffer objects 内存能够被部分或全部清除为指定的值。这些函数的工作原理与Pixel Transfer操作类似。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glClearBufferData</span><span class="params">(GLenum <span class="keyword">target</span>, GLenum internalformat, GLenum format, GLenum type, <span class="keyword">const</span> <span class="keyword">void</span> * data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glClearBufferSubData</span><span class="params">(GLenum <span class="keyword">target</span>, GLenum internalformat, GLintptr offset,  GLsizeiptr size, GLenum format, GLenum type, <span class="keyword">const</span> <span class="keyword">void</span> * data)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>一个清除全部内容，一个清除部分内容</p>
<h2 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h2><p>一个buffer的数据可以被复制到另一个buffer，我们为源和目标buffer绑定不同的target, 一般使用GL_COPY_READ_BUFFER GL_COPY_WRITE_BUFFER作为相应的标志。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glCopyBufferSubData​(GLenum readtarget​, GLenum writetarget​, GLintptr readoffset​,GLintptr writeoffset​, GLsizeiptr <span class="built_in">size</span>​);</span><br></pre></td></tr></table></figure></p>
<p>readtarget是绑定到source buffer上的buffer, 这是复制数据的提供者，writetarget 是绑定到destination buffer的buffer，是复制数据的接受者。</p>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>对于一般情况来说，glBufferSubData是一种很好的更新数据方式。但有时取决你的使用方式，它的性能会减低。例如，你的算法生成了一些将要存储至buffer object的数据，你首先必须为这些数据分配暂时的存储区，然后使用glBufferSubData函数复制到OpenGL管理的内存。当你想要将数据写回时，glGetBufferSubData也许并不是你想要的方式， 虽然它看起来功能相像。如果你能得到一个指向buffer object存储区的指针，然后直接写入，这样的方式会非常好。<br>为了达到上面所说的效果，你必须对buffer进行映射以得到一个指向可读写buffer内存的指针。<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *glMapBufferRange​(GLenum target​, GLintptr <span class="keyword">offset</span>​, GLsizeiptr <span class="built_in">length</span>​,GLbitfield access​);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="General-use"><a href="#General-use" class="headerlink" title="General use"></a>General use</h1><ul>
<li>GL_ARRAY_BUFFER</li>
<li>GL_ELEMENT_ARRAY_BUFFER</li>
<li>GL_COPY_READ_BUFFER &amp; GL_COPY_WRITE_BUFFER</li>
<li>GL_PIXEL_UNPACK_BUFFER &amp; GL_PIXEL_PACK_BUFFER</li>
<li>GL_QUERY_BUFFER</li>
<li>GL_TEXTURE_BUFFER</li>
<li>GL_TRANSFORM_FEEDBACK_BUFFER</li>
<li>GL_UNIFORM_BUFFER</li>
<li>GL_DRAW_INDIRECT_BUFFER</li>
<li>GL_ATOMIC_COUNTER_BUFFER</li>
<li>GL_DISPATCH_INDIRECT_BUFFER</li>
<li>GL_SHADER_STORAGE_BUFFER</li>
</ul>
<p>##Binding indexed targets<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> glBindBufferRange​(GLenum target​, GLuint <span class="keyword">index</span>​, GLuint <span class="keyword">buffer</span>​,  GLintptr <span class="keyword">offset</span>​, GLsizeiptr size​ );</span><br></pre></td></tr></table></figure></p>
<h2 id="Multibind-and-indexed-targets"><a href="#Multibind-and-indexed-targets" class="headerlink" title="Multibind and indexed targets"></a>Multibind and indexed targets</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glBindBuffersRange​(GLenum <span class="keyword">target</span>​, GLuint first​, GLsizei count​, <span class="keyword">const</span> GLuint *buffers​, <span class="keyword">const</span> GLintptr *offsets​, <span class="keyword">const</span> GLintptr *sizes​);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Direct3D-Pipeline]]></title>
      <url>https://byhj.github.io/blog/blog/2015/09/18/Direct3D-Pipeline/</url>
      <content type="html"><![CDATA[<h1 id="DirectX-Pipeline"><a href="#DirectX-Pipeline" class="headerlink" title="DirectX Pipeline"></a>DirectX Pipeline</h1><hr>
<a id="more"></a>
<h2 id="DirectX9"><a href="#DirectX9" class="headerlink" title="DirectX9"></a>DirectX9</h2><p><img src="http://7xlvtd.com1.z0.glb.clouddn.com/15-9-18/61135679.jpg" alt="D3D9"></p>
<hr>
<h2 id="DirectX10"><a href="#DirectX10" class="headerlink" title="DirectX10"></a>DirectX10</h2><p><img src="http://7xlvtd.com1.z0.glb.clouddn.com/15-9-18/46463470.jpg" alt="D3D10"></p>
<hr>
<h2 id="DirectX11"><a href="#DirectX11" class="headerlink" title="DirectX11"></a>DirectX11</h2><p><img src="http://7xlvtd.com1.z0.glb.clouddn.com/15-9-18/6328682.jpg" alt="D3D11"></p>
<hr>
<h2 id="DirectCompute"><a href="#DirectCompute" class="headerlink" title="DirectCompute"></a>DirectCompute</h2><p><img src="http://7xlvtd.com1.z0.glb.clouddn.com/15-9-18/63515085.jpg" alt="DirectCompute"></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-Rendering Pipeline]]></title>
      <url>https://byhj.github.io/blog/blog/2015/09/17/OpenGL-RenderingPipeline/</url>
      <content type="html"><![CDATA[<p>OpenGL渲染流水线</p>
<a id="more"></a>
<p><img src="http://7xlvtd.com1.z0.glb.clouddn.com/OpenGLRenderingPipeline-1.png" alt="RenderingPipeline1"></p>
<p><img src="http://7xlvtd.com1.z0.glb.clouddn.com/15-9-21/27893569.jpg" alt="RenderingPipeline2"></p>
<p><img src="http://7xlvtd.com1.z0.glb.clouddn.com/15-9-21/29976945.jpg" alt="RenderingPipelineMap"></p>
<hr>
<h1 id="Vertex-Specification"><a href="#Vertex-Specification" class="headerlink" title="Vertex Specification"></a>Vertex Specification</h1><h2 id="Vertex-Rendering"><a href="#Vertex-Rendering" class="headerlink" title="Vertex Rendering"></a>Vertex Rendering</h2><h2 id="Primitive"><a href="#Primitive" class="headerlink" title="Primitive"></a>Primitive</h2><hr>
<h1 id="Vertex-Processing"><a href="#Vertex-Processing" class="headerlink" title="Vertex Processing"></a>Vertex Processing</h1><h2 id="Vertex-Shader"><a href="#Vertex-Shader" class="headerlink" title="Vertex Shader"></a>Vertex Shader</h2><h2 id="Tessellation"><a href="#Tessellation" class="headerlink" title="Tessellation"></a>Tessellation</h2><h2 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h2><hr>
<h1 id="Vertex-pos-processing"><a href="#Vertex-pos-processing" class="headerlink" title="Vertex pos-processing"></a>Vertex pos-processing</h1><h2 id="Transform-Feedback"><a href="#Transform-Feedback" class="headerlink" title="Transform Feedback"></a>Transform Feedback</h2><h2 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h2><hr>
<h1 id="Primitive-assembly"><a href="#Primitive-assembly" class="headerlink" title="Primitive assembly"></a>Primitive assembly</h1><h2 id="Face-Culling"><a href="#Face-Culling" class="headerlink" title="Face Culling"></a>Face Culling</h2><hr>
<h1 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h1><hr>
<h1 id="Fragment-Processing"><a href="#Fragment-Processing" class="headerlink" title="Fragment Processing"></a>Fragment Processing</h1><hr>
<h1 id="Per-Sample-Operations"><a href="#Per-Sample-Operations" class="headerlink" title="Per-Sample Operations"></a>Per-Sample Operations</h1><h2 id="Scrissor-Test"><a href="#Scrissor-Test" class="headerlink" title="Scrissor Test"></a>Scrissor Test</h2><h2 id="Stencil-Test"><a href="#Stencil-Test" class="headerlink" title="Stencil Test"></a>Stencil Test</h2><h2 id="Depth-Test"><a href="#Depth-Test" class="headerlink" title="Depth Test"></a>Depth Test</h2><h2 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h2><h2 id="Logical-Operations"><a href="#Logical-Operations" class="headerlink" title="Logical Operations"></a>Logical Operations</h2><h2 id="Masking-operations"><a href="#Masking-operations" class="headerlink" title="Masking operations"></a>Masking operations</h2><hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL-Objects]]></title>
      <url>https://byhj.github.io/blog/blog/2015/09/17/OpenGL-Objects/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p> 　　在OpenGL中，OpenGL Objects是一种包含着一些状态的结构。当你把OpenGL Objects绑定到上下文环境时，Objects内含的状态就会映射到上下文环境中的状态。在这个时候，如果你通过API函数修改了上下文中的状态，对应OpenGL Ojects内的状态也会被修改。<br>　　 OpenGL被定义为一种“状态机”，它所提供的多种API函数调用可以改变OpenGL的状态，也可以查询某些状态量，或者使用当前的状态去Rendering。<br>　　 OpenGL有着多种类型的Ojbects, 它们存储着不同的状态，一组状态被封装在一个OpenGL Objects中，我们可以通过函数调用去改变它们。<br>　　 需要注意的是，OpenGL只是制定相应的规范，具体实现是由各个显卡驱动的厂商决定的，但实现也一般都会符合OpenGL制定的规范。</p>
<hr>
<a id="more"></a>
<h1 id="Creation-amp-Destruction"><a href="#Creation-amp-Destruction" class="headerlink" title="Creation &amp; Destruction"></a>Creation &amp; Destruction</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glGen*(GLsizei n, GLuint *objects)</span><br></pre></td></tr></table></figure>
<p> 　　该函数创建n个对象名称(整数值引用)，返回指向这些objects的指针。在这一步，并不需要创建objects的状态数据。对于大多数object来说，在第一次绑定到上下文时，只包含其默认状态。在绑定前使用Objects是非法的。需要注意的是，Program Pipeline Ojbects和 Sampler Objects并不遵循这种运行机制。<br> 　　Object名称类型是GLuint, 它是一个数值型引用，用来识别一个object, 其中数值0在不同的Object中有着特定意义。<br>  （在OpenGL3.0之前，可以完全忽略上述的的分配函数,直接绑定认为合法的Ojbect名称）<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glDelete*(GLsizei n​, <span class="keyword">const</span> GLuint *objects​);</span><br></pre></td></tr></table></figure></p>
<p> 　　当我们使用完Objects，可以使用上面函数进行删除。任何非法Object和Object 0会被忽略。Objects被删除后，它们的名字可以通过glGen*重新分配。</p>
<h2 id="Deletion-unbinding"><a href="#Deletion-unbinding" class="headerlink" title="Deletion unbinding"></a>Deletion unbinding</h2><p>　　当绑定到当前context的object被删除时，会解除所有该object的绑定。<br>（Binding goes to the context; attachment is what you do when one object references another. Attachments are not severed due to this call.）<br>　　当一个object attached到container object，而该object绑定到context，删除会解除attach操作，如果该object没有绑定到context, attach操作不会被破坏。</p>
<p>Some objects can be bound to the context in unusual ways. These ways include, but are not limited to:</p>
<ul>
<li>Buffer Objects bound to indexed targets via glBindBufferRange​ or its equivalents.</li>
<li>Textures bound as images.</li>
</ul>
<h2 id="Deletion-orphaning"><a href="#Deletion-orphaning" class="headerlink" title="Deletion orphaning"></a>Deletion orphaning</h2><p>　　调用glDelete”并不保证马上消除object的内容和它的名字，如果一个object在删除后还被使用，那么当前object名字还是合法的。</p>
<p>An object is “in use” if:</p>
<ul>
<li>It is bound to a context. This is not necessarily the current one, since deleting it will automatically unbind it from the context that caused the deletion. Though remember the caveat above about non-standard binding points for GL 4.4 and before.</li>
<li>It is attached to a container object.</li>
</ul>
<hr>
<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>　　由于Ojbects是一组状态，当要修改Ojbects前，需要把它绑定到OpenGL context。在绑定后，调用API函数可以对context中的状态进行改变，Objects的相应状态也会被改变。在绑定一个新生成的Object名称时，会为这个Object产生新的状态</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glBind*(GLenum <span class="keyword">target</span>​, GLuint object​);</span><br></pre></td></tr></table></figure>
<h2 id="Object-zero"><a href="#Object-zero" class="headerlink" title="Object zero"></a>Object zero</h2><p> 　　数值0在一些OpenGL Objects中有着特定的含义。在大多数情况下，object 0就像是空指针NULL，是一种指示作用。对于一些Objects来说，0代表“default object”, Texture 和 Framebuffers都有着这样的概念。</p>
<hr>
<h1 id="Multibind"><a href="#Multibind" class="headerlink" title="Multibind"></a>Multibind</h1><p>　　在OpenGL4.4引入了多重绑定概念，可以一次把不同类型的Objects绑定到各自的目标上，这种方式只是用来绑定后使用而不是修改。在多重绑定中，任何一个绑定错误都会导致整体的错误。</p>
<hr>
<h1 id="Sharing"><a href="#Sharing" class="headerlink" title="Sharing"></a>Sharing</h1><p>　　你可以创建多个OpenGL contexts, 而当前GL context是线程相关的，一般来说它们各自是完成独立开来的，不会相互影响。但是context创建的时候，你可以使用另一个已经存在context的Objects. 需要注意，那些包含着其它Objects引用的Objects不能被共享，剩下的Objects可以进行context间共享，包括GLSL Objects和Sync Objects这种不遵循OpenGL Object机制的Objects.<br>　　一个context中Objects状态的改变并不是在另一个context马上可见，在这里有着特定的规则保证object状态数据的可见性。如果你使用线程，你需要自己做一些同步处理工作以保证在一个context使用那些会改变的objects之前，objects的改变在另一个context中已经完成。</p>
<hr>
<h1 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h1><p>　　Objects can be separated into two different categories: regular objects and container objects. Here is the list of regular objects.</p>
<p><strong>Regular objects</strong></p>
<ul>
<li>Buffer Objects</li>
<li>Query Objects</li>
<li>Renderbuffer Objects</li>
<li>Sampler Objects</li>
<li>Texture Objects</li>
</ul>
<p><strong>Container objects</strong></p>
<ul>
<li>Framebuffer Objects</li>
<li>Program Pipeline Objects</li>
<li>Transform Feedback Objects</li>
<li>Vertex Array Objects</li>
</ul>
<hr>
<h1 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h1><p>　　正如上面所说，OpenGL Ojbects的名字是一个由系统分配的整数值，这种方式对于用户并不直观，在调试时也有很大的缺陷。在OpenGL 4.3 Core引入了一种为Object作标志的方法。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> glObjectLabel​(<span class="type">GLenum</span> identifier​, <span class="type">GLuint</span> name​, </span><br><span class="line">                   <span class="type">GLsizei</span> length​, <span class="keyword">const</span> <span class="built_in">char</span> * label​);</span><br><span class="line">                   </span><br><span class="line"><span class="built_in">void</span> glObjectPtrLabel​(<span class="built_in">void</span> * <span class="keyword">ptr</span>​, <span class="type">GLsizei</span> length​, <span class="keyword">const</span> <span class="built_in">char</span> * label​);</span><br></pre></td></tr></table></figure></p>
<p>第一种方法可以为所有的Objects设置Label，第二种为Sync Objects设置Label</p>
<table>
<thead>
<tr>
<th>Identifier</th>
<th style="text-align:center">Object Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_BUFFER</td>
<td style="text-align:center">Buffer Object</td>
</tr>
<tr>
<td>GL_SHADER</td>
<td style="text-align:center">Shader Object</td>
</tr>
<tr>
<td>GL_PROGRAM</td>
<td style="text-align:center">Program Object</td>
</tr>
<tr>
<td>GL_VERTEX_ARRAY</td>
<td style="text-align:center">Vertex Array Object</td>
</tr>
<tr>
<td>GL_QUERY</td>
<td style="text-align:center">Query Object</td>
</tr>
<tr>
<td>GL_PROGRAM_PIPELINE</td>
<td style="text-align:center">Program Pipeline Object</td>
</tr>
<tr>
<td>GL_TRANSFORM_FEEDBACK</td>
<td style="text-align:center">Transform Feedback Object</td>
</tr>
<tr>
<td>GL_SAMPLER</td>
<td style="text-align:center">Sampler Object</td>
</tr>
<tr>
<td>GL_TEXTURE</td>
<td style="text-align:center">Texture Object</td>
</tr>
<tr>
<td>GL_RENDERBUFFER</td>
<td style="text-align:center">Renderbuffer Object</td>
</tr>
<tr>
<td>GL_FRAMEBUFFER</td>
<td style="text-align:center">Framebuffer Object</td>
</tr>
</tbody>
</table>
<p>查询设置Label的Objects<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> glGetObjectLabel​(<span class="type">GLenum</span> identifier​, <span class="type">GLuint</span> name​, <span class="type">GLsizei</span> bufSize​,</span><br><span class="line">                      <span class="type">GLsizei</span> * length​, <span class="built_in">char</span> * label​);</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> glGetObjectPtrLabel​(<span class="built_in">void</span> * <span class="keyword">ptr</span>​, <span class="type">GLsizei</span> bufSize​, </span><br><span class="line">                         <span class="type">GLsizei</span> * length​, <span class="built_in">char</span> * label​);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p>　　The following are “objects”, but they do not follow the standard conventions laid out on this page for OpenGL objects:</p>
<ul>
<li>Sync Objects</li>
<li>Shader and Program Objects</li>
</ul>
<p>Except for program pipeline objects, which do follow the OpenGL Object conventions.</p>
<p><a href="https://www.opengl.org/wiki/OpenGL_Object" target="_blank" rel="external">–Original: OpenGL Wiki–</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Direct3D12-Glossary]]></title>
      <url>https://byhj.github.io/blog/blog/2015/09/15/Direct3D12-Glossary/</url>
      <content type="html"><![CDATA[<p>These terms are distinctive of Direct3D 12.</p>
<hr>
<h1 id="binding"><a href="#binding" class="headerlink" title="binding"></a>binding</h1><p>  The process of attaching memory to the graphics pipeline. Resource binding, for example, involves the binding of a resource such as a texture to the pipeline, for use in rendering an object.</p>
<hr>
<h1 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h1><p>  A type of D3D resource that is synonymous with a contiguous memory allocation.</p>
<hr>
<h1 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h1><p>  A command buffer that the graphics processing unit (GPU) can execute only directly via a direct command list. A bundle inherits all GPU state (except for the currently set pipeline state object and primitive topology).</p>
<a id="more"></a>
<hr>
<h1 id="command-allocator"><a href="#command-allocator" class="headerlink" title="command allocator"></a>command allocator</h1><p>  The underlying memory allocations in which GPU commands are stored. The command allocator object applies to both direct command lists and bundles.</p>
<hr>
<h1 id="command-list"><a href="#command-list" class="headerlink" title="command list"></a>command list</h1><p>  A command list corresponds to a set of commands which the GPU executes. These include commands such as to set state, draw, clear, and copy. The D3D12 command list interface is significantly different than the D3D11 command list interface. The D3D12 command list interface contains APIs similar to the D3D11 device context rendering APIs.</p>
<p>  A D3D12 command list does not map or unmap resources, change tile mappings, resize tile pools, get query data, nor does it ever implicitly submit commands to the GPU for execution.</p>
<p>  Unlike D3D11 deferred contexts, D3D12 command lists only support two levels of indirection. A direct command list corresponds to a command buffer which the GPU can execute. A bundle can be executed only directly via a direct command list.</p>
<p>  A direct command list does not inherit any GPU state. A bundle inherits all GPU state (except for the currently set pipeline state object and primitive topology).</p>
<p>  Memory for a command list is set by the command allocator. The purpose of command lists is that they can be submitted to a GPU as a single rendering request.</p>
<hr>
<h1 id="command-queue"><a href="#command-queue" class="headerlink" title="command queue"></a>command queue</h1><p>  A queue of command lists that the GPU executes in succession. Applications must explicitly submit command lists to a command queue for execution. Typically there are three command queues: 3D graphics, compute and copy, corresponding to the 3D graphics pipeline, the compute engine, and one or more copy engines, on the GPU.</p>
<hr>
<h1 id="conservative-rasterization"><a href="#conservative-rasterization" class="headerlink" title="conservative rasterization"></a>conservative rasterization</h1><p>  Conservative rasterization is a mode of operation for the rasterizer stage of the Direct3D graphics pipeline. It disables the standard sample-based rasterization, and will instead rasterize a pixel that is covered by any amount by a primitive. One important distinction is that, while any coverage at all produces a rasterized pixel, that coverage cannot be characterized by the hardware, so coverage always appears binary to a pixel shader: either fully covered or not covered. It is left to the pixel shader code to analytically determine the actual coverage.</p>
<p>  Conservative rasterization can help with such problems as collision and hit detection, binning, and occlusion culling, where the color of a pixel is more certain and edge cases can be eliminated. See Conservative Rasterization.</p>
<hr>
<h1 id="Constant-Buffer-View-CBV"><a href="#Constant-Buffer-View-CBV" class="headerlink" title="Constant Buffer View (CBV)"></a>Constant Buffer View (CBV)</h1><p>  Constant buffers contain shader constant data, such as a camera view, projection matrices, and world matrices. A “constant buffer view” is the format-specific view of the buffer as seen by the graphics pipeline.</p>
<hr>
<h1 id="default-heap"><a href="#default-heap" class="headerlink" title="default heap"></a>default heap</h1><p>  A user-mode heap that is focused on supporting persistent GPU resource types, including GPU-written resources.</p>
<hr>
<h1 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a>descriptor</h1><p>  Descriptors are the primary unit of binding for a single resource in D3D12. A descriptor is a relatively small block of data that fully describes an object to the GPU, in a GPU specific format. There are many different types of descriptors: Shader Resource Views (SRVs), Unordered Access Views (UAVs), Constant Buffer Views (CBVs), and Samplers are a few examples.</p>
<hr>
<h1 id="descriptor-heap"><a href="#descriptor-heap" class="headerlink" title="descriptor heap"></a>descriptor heap</h1><p>  A descriptor heap is a collection of contiguous allocations of descriptors, one allocation for every descriptor. The primary point of a descriptor heap is to encompass the bulk of memory allocation required for storing the descriptor specifications of object types that shaders reference for as large of a window of rendering as possible (ideally an entire frame of rendering or more).</p>
<hr>
<h1 id="descriptor-table"><a href="#descriptor-table" class="headerlink" title="descriptor table"></a>descriptor table</h1><p>  A descriptor table is logically an array of descriptors. Each descriptor table stores descriptors of one or more types, including SRVs, UAVe, CBVs, and Samplers. A descriptor table is not an allocation of memory, it is simply an offset and length into a descriptor heap.</p>
<hr>
<h1 id="direct-command-list"><a href="#direct-command-list" class="headerlink" title="direct command list"></a>direct command list</h1><p>  A command buffer that the GPU can execute. A direct command list doesn’t inherit any GPU state.</p>
<hr>
<h1 id="fence"><a href="#fence" class="headerlink" title="fence"></a>fence</h1><p>  A mechanism to synchronize the GPU and CPU. Both the GPU and CPU can be instructed to wait at a fence, waiting in effect for the other processor to catch up. See Synchronization and Multi-Engine.</p>
<hr>
<h1 id="hazard-hazard-tracking"><a href="#hazard-hazard-tracking" class="headerlink" title="hazard, hazard tracking"></a>hazard, hazard tracking</h1><p>  A hazard occurs when a resource has been used for one purpose, and the app intends to reuse it for another purpose. In order to use the resource again, intermediate caches will need to be flushed or invalidated, compression requirements will need to be consistent with the second use, and the resource should be in the required state to avoid reading the resource after it has been written to and invalidated for the intended purpose.</p>
<p>  The process of maintaining resources and avoiding these sync issues is known as hazard tracking. If there is no hazard tracking by the driver, then the app is responsible for this. In most earlier versions of DirectX, hazard tracking was handled by the driver. To improve performance, methods without hazard tracking are available in DirectX 12.</p>
<hr>
<h1 id="High-Level-Shader-Language-HLSL"><a href="#High-Level-Shader-Language-HLSL" class="headerlink" title="High-Level Shader Language (HLSL)"></a>High-Level Shader Language (HLSL)</h1><p>  A computer language, similar but distinct in many ways from C, that is used to write shader code. Vertex, pixel, geometry, compute, domain, and hull shaders are all written using HLSL. A compiler converts the HLSL source into a binary format for the GPU to consume.</p>
<hr>
<h1 id="multiengine"><a href="#multiengine" class="headerlink" title="multiengine"></a>multiengine</h1><p>  The different instances and types of engines in a single GPU. The types of engines include: graphics, compute, and copy.</p>
<hr>
<h1 id="MultiGPU"><a href="#MultiGPU" class="headerlink" title="MultiGPU"></a>MultiGPU</h1><p>  A hardware configuration where there is more than on graphics adapter. The separate adapters are sometimes referred to as nodes. Having multiple GPUs can make the task of synchronizing them with the CPU, and each other, considerably more complex than with a single GPU.</p>
<hr>
<h1 id="Pipeline-State-object-PSO"><a href="#Pipeline-State-object-PSO" class="headerlink" title="Pipeline State object (PSO)"></a>Pipeline State object (PSO)</h1><p>  A significant portion of the state of the GPU. This state includes all currently set shaders and certain fixed-function state objects. The only way to change states contained within the pipeline object is to change the currently bound pipeline object.</p>
<hr>
<h1 id="predication"><a href="#predication" class="headerlink" title="predication"></a>predication</h1><p>  Predication is a feature that enables the GPU rather than the CPU to determine to not draw, copy or dispatch an object. For example, if a bounding box of an object is totally occluded by another object or perspective has reduced the object to less than the size of a pixel, there may be no point in attempting to draw the hidden object at all. See Predication.</p>
<hr>
<h1 id="Rasterizer-Order-View-ROV"><a href="#Rasterizer-Order-View-ROV" class="headerlink" title="Rasterizer Order View (ROV)"></a>Rasterizer Order View (ROV)</h1><p>  Standard graphics pipelines may have trouble correctly compositing together multiple textures that contain transparency. Objects such as wire fences, smoke, fire, vegetation, and colored glass use transparency to get the desired effect. Problems arise when multiple textures that contain transparency are in line with each other (smoke in front of a fence in front of a glass building containing vegetation, as an example). Rasterizer ordered views (ROVs) enable the underlying Order Independent Transparency (OIT) algorithms to use features of the hardware to try to resolve the transparency order correctly. Transparency is handled by the pixel shader.</p>
<p>  Rasterizer Ordered Views (ROVs) allow pixel shader code to mark Unordered Access View (UAV) bindings with a declaration that alters the normal requirements for the order of graphics pipeline results for UAVs.</p>
<hr>
<h1 id="readback-heap"><a href="#readback-heap" class="headerlink" title="readback heap"></a>readback heap</h1><p>  A user-mode heap that is focused on data transfer from the GPU back to the CPU.</p>
<hr>
<h1 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h1><p>  An entity that provides data to the pipeline and defines what is rendered during your scene. Resources can be loaded from your game media or created dynamically at run time. Typically, resources include texture data, vertex data, and shader data. Most Direct3D applications create and destroy resources extensively throughout their lifespan.</p>
<hr>
<h1 id="resource-barrier"><a href="#resource-barrier" class="headerlink" title="resource barrier"></a>resource barrier</h1><p>  A resource barrier notifies the driver that synchronization of multiple accesses to a single resource may be required, for example, reading and writing to the same texture.</p>
<hr>
<h1 id="resource-binding"><a href="#resource-binding" class="headerlink" title="resource binding"></a>resource binding</h1><p>  Resource binding is the process of linking resources (textures, vertex buffers, index buffers, and so on), to the graphics pipeline, enabling the shaders of the pipeline to process the correct resource.</p>
<hr>
<h1 id="resource-heaps"><a href="#resource-heaps" class="headerlink" title="resource heaps"></a>resource heaps</h1><p>  Resource heaps is a generic term for the heaps that are memory buffers set aside to hold resources as they are transferred to and from the GPU. A transfer to the GPU requires an Upload Heap, from the GPU to the CPU requires a Readback Heap, and a persistent heap for the GPU to maintain over multiple rendering frames is called a Default Heap.</p>
<hr>
<h1 id="root-signature"><a href="#root-signature" class="headerlink" title="root signature"></a>root signature</h1><p>  Root signatures define all the resources that are to be bound to the graphics, or compute, pipelines. A root signature is configured by the app and links command lists to the resources that the shaders require Typically, there is one graphics and one compute root signature per app.</p>
<hr>
<h1 id="sampler"><a href="#sampler" class="headerlink" title="sampler"></a>sampler</h1><p>  A sampler is code that reads from a texture.</p>
<hr>
<h1 id="Shader-Resource-View-SRV"><a href="#Shader-Resource-View-SRV" class="headerlink" title="Shader Resource View (SRV)"></a>Shader Resource View (SRV)</h1><p>  A format-specific way to look at the data in a shader resource, such as a texture.</p>
<hr>
<h1 id="static-heap"><a href="#static-heap" class="headerlink" title="static heap"></a>static heap</h1><p>  A user-mode heap that is focused on multiple GPU-read-only resources that are typically used at the same time and are not changed frequently.</p>
<hr>
<h1 id="swap-chain"><a href="#swap-chain" class="headerlink" title="swap chain"></a>swap chain</h1><p>  Swap chains control the back buffer rotation, forming the basis of graphics animation. Swap chains are handled by the low level API set DXGI (see DXGI Overview).</p>
<hr>
<h1 id="swizzle"><a href="#swizzle" class="headerlink" title="swizzle"></a>swizzle</h1><p>  A technique of locating multidimensional data in memory such that data of nearby dimensionality tends to have nearby addresses. In particular, all the data for one row is not located contiguously before the data for the next row. A “Parameterized Swizzle” describes a standardized way to describe swizzle patterns.</p>
<hr>
<h1 id="texture"><a href="#texture" class="headerlink" title="texture"></a>texture</h1><p>  A type of D3D resource that is multi-dimensional and has a memory layout that is optimized for multi-dimensional access from the GPU. Textures often contain the raw image required to render onto a surface, before lighting and blending takes place, but can contain other forms of data such as color gradients and reference colors. Direct3D 12 supports one, two, and three dimensional textures.</p>
<hr>
<h1 id="tile"><a href="#tile" class="headerlink" title="tile"></a>tile</h1><p>  A page of video memory, similar to a CPU/System page of memory. The tile notation helps to distinguish the GPU virtual memory subsystem from the CPU virtual memory subsystem. GPUs provide similar virtual memory capabilities as system virtual memory. Some GPUs have shared virtual memory capabilities, which allow for the sharing of some pages of the virtual memory subsystem with both the CPU and GPU.</p>
<hr>
<h1 id="tiled-resources"><a href="#tiled-resources" class="headerlink" title="tiled resources"></a>tiled resources</h1><p>  Tiled resources are needed so less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles. Tiled resources are large logical resources, but requiring small amounts of physical memory.</p>
<hr>
<h1 id="Unordered-Access-View-UAV"><a href="#Unordered-Access-View-UAV" class="headerlink" title="Unordered Access View (UAV)"></a>Unordered Access View (UAV)</h1><p>  An unordered access view into a resource (which includes buffers, textures, and texture arrays - without multi-sampling), allows temporally unordered read/write access from multiple threads. This means that this resource type can be read/written simultaneously by multiple threads without generating memory conflicts.</p>
<hr>
<h1 id="upload-heap"><a href="#upload-heap" class="headerlink" title="upload heap"></a>upload heap</h1><p>  A user-mode heap that is focused on data transfer from the CPU to the GPU.</p>
<hr>
<h1 id="user-mode-heap"><a href="#user-mode-heap" class="headerlink" title="user-mode heap"></a>user-mode heap</h1><p>  A collection of large, contiguous memory allocations that are recycled without any kernel component’s awareness: the allocation and destruction methods do not call kernel allocation and destruction methods during steady state. Upload, Readback, and Default heaps are variants of user mode heaps.</p>
<hr>
<h1 id="volume-tiled-resources"><a href="#volume-tiled-resources" class="headerlink" title="volume tiled resources"></a>volume tiled resources</h1><p>  Three-dimensional tiled resources.</p>
<hr>
]]></content>
    </entry>
    
  
  
</search>
